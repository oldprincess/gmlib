SM4 算法
====================

SM4 官方文档参考 http://www.gmbz.org.cn/main/viewfile/20180108015408199368.html

----

===================== ==== ====================
宏定义                  值  含义
===================== ==== ====================
SM4_BLOCK_SIZE          16  分组字节数
SM4_FAST_BLOCK_SIZE     16  最快加解密分组字节数
SM4_KEYLEN              16  密钥字节数
===================== ==== ====================

分组密码常用的优化策略为利用 ``SIMD`` 指令集并行加解密多个分组，以提升效率。
``SM4_FAST_BLOCK_SIZE`` 与这一并行优化方式有关，主要用于工作模式之中。


####################
一、SM4 加解密
####################

.. c:struct:: SM4_Key

    .. c:var:: uint32_t rk[32]
        
        SM4 32 轮轮密钥

.. c:function:: void sm4_keyinit(uint8_t* key, SM4_Key* sm4key);

    SM4 轮密钥生成

.. c:function:: void sm4_encrypt(uint8_t* out, uint8_t* in, int block_num, SM4_Key* sm4key);

    SM4 ECB模式加密

.. c:function:: void sm4_decrypt(uint8_t* out, uint8_t* in, int block_num, SM4_Key* sm4key);

    SM4 ECB模式解密

.. note:: 

    SM4 加解密函数 ``sm4_encrypt`` 和 ``sm4_decrypt`` 均以分组数作为输入，
    例如若需要加密长度为 ``L`` 字节的数据，则参数 ``block_num`` 应为 ``L / SM4_BLOCK_SIZE``

.. code-block:: c
    :caption: example

    // 128比特密钥
    uint8_t key[SM4_KEYLEN] = {
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    };

    // 128比特明文
    uint8_t plaintext[SM4_BLOCK_SIZE] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    };

    // 128比特密文输出
    uint8_t out[SM4_BLOCK_SIZE];

    SM4_Key sm4key;
    // SM4 轮密钥初始化
    sm4_keyinit(key, &sm4key);
    // SM4 加密
    sm4_encrypt(out, plaintext, sizeof(plaintext) / SM4_BLOCK_SIZE, &sm4key);


####################
二、SM4 ECB 模式
####################

.. c:struct:: SM4_ECB_CTX
    
    .. c:var:: SM4_Key sm4key

        SM4 轮密钥

    .. c:var:: uint8_t buffer[SM4_FAST_BLOCK_SIZE]
        
        缓冲区

    .. c:var:: int bsize

        buffer 长度

.. note:: 

    SM4 ECB 模式默认采用 pkcs7 填充，若不想使用填充可调用低层的 ``sm4_encrypt`` 函数

.. c:function:: void sm4_ecb_init(uint8_t* key, SM4_ECB_CTX* ecb_ctx);

    SM4 ECB模式初始化

.. c:function:: void sm4_ecb_reset(SM4_ECB_CTX* ecb_ctx);

    SM4 ECB模式Context重置

.. c:function:: void sm4_ecb_encrypt_update(uint8_t* out, int* outl, uint8_t* in, int inl, \
                                            SM4_ECB_CTX* ecb_ctx);

    SM4 ECB加密模式Update数据

.. c:function:: void sm4_ecb_decrypt_update(uint8_t* out, int* outl, uint8_t* in, int inl, \
                                            SM4_ECB_CTX* ecb_ctx);

    SM4 ECB解密模式Update数据

.. c:function:: void sm4_ecb_encrypt_final(uint8_t* out, int* outl, SM4_ECB_CTX* ecb_ctx);

    SM4 ECB加密模式Final

.. c:function:: int sm4_ecb_decrypt_final(uint8_t* out, int* outl, SM4_ECB_CTX* ecb_ctx);

    SM4 ECB解密模式Final

.. code-block:: c
    :caption: example

    #include <gmlib/bint.h>
    #include <gmlib/cipher/sm4.h>
    #include <gmlib/utils.h>

    int main() {
        uint8_t key[SM4_KEYLEN] = {0};
        uint8_t plaintext[SM4_BLOCK_SIZE] = {0};
        uint8_t ciphertext[SM4_BLOCK_SIZE * 2];

        SM4_ECB_CTX sm4_ecb_ctx;       // ECB Context
        uint8_t* outptr = ciphertext;  // 输出指针
        int outl = 0;                  // 输出长度

        sm4_ecb_init(key, &sm4_ecb_ctx);
        sm4_ecb_encrypt_update(outptr, &outl,               // output
                            plaintext, sizeof(plaintext),   // input
                            &sm4_ecb_ctx);
        outptr += outl;
        sm4_ecb_encrypt_final(outptr, &outl, &sm4_ecb_ctx);
        outptr += outl;
        //  9f 1f 7b ff 6f 55 11 38 4d 94 30 53 1e 53 8f d3
        //  a8 3f 90 cc 9f 35 ca c4 da f6 6b fa 07 1c 41 82
        dump_data(ciphertext, (int)(outptr - ciphertext));

        int csize = (int)(outptr - ciphertext);  // 密文长度
        outptr = plaintext;
        sm4_ecb_reset(&sm4_ecb_ctx);
        sm4_ecb_decrypt_update(outptr, &outl, ciphertext, csize, &sm4_ecb_ctx);
        outptr += outl;
        sm4_ecb_decrypt_final(outptr, &outl, &sm4_ecb_ctx);
        outptr += outl;
        //  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
        dump_data(plaintext, (int)(outptr - plaintext));

        return 0;
    }


####################
二、SM4 CBC 模式
####################

.. c:struct:: SM4_CBC_CTX
    
    .. c:var:: SM4_Key sm4key

        SM4 轮密钥

    .. c:var:: uint8_t iv[SM4_BLOCK_SIZE]

        CBC 模式初始向量 iv

    .. c:var:: uint8_t buffer[SM4_FAST_BLOCK_SIZE]
        
        缓冲区

    .. c:var:: int bsize

        buffer 长度

.. note:: 

    SM4 CBC 模式默认采用 pkcs7 填充，因为填充的原因，密文长度将会比明文长度长

.. c:function:: void sm4_cbc_init(uint8_t* key, uint8_t* iv, SM4_CBC_CTX* cbc_ctx);

    SM4 CBC模式初始化

.. c:function:: void sm4_cbc_reset(uint8_t* iv, SM4_CBC_CTX* cbc_ctx);

    SM4 CBC模式Context重置

.. c:function:: void sm4_cbc_encrypt_update(uint8_t* out, int* outl, uint8_t* in, int inl, \
                                            SM4_CBC_CTX* cbc_ctx);

    SM4 CBC加密模式Update数据

.. c:function:: void sm4_cbc_decrypt_update(uint8_t* out, int* outl, uint8_t* in, int inl, \
                                            SM4_CBC_CTX* cbc_ctx);

    SM4 CBC解密模式Update数据

.. c:function:: void sm4_cbc_encrypt_final(uint8_t* out, int* outl, SM4_CBC_CTX* cbc_ctx);

    SM4 CBC加密模式Final

.. c:function:: int sm4_cbc_decrypt_final(uint8_t* out, int* outl, SM4_CBC_CTX* cbc_ctx);

    SM4 CBC解密模式Final

.. code-block:: c
    :caption: example

    #include <gmlib/cipher/sm4.h>
    #include <gmlib/utils.h>

    // 128比特密钥
    uint8_t key[SM4_KEYLEN] = {
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,  //
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,  //
    };

    // 128比特初始向量
    uint8_t iv[SM4_KEYLEN] = {
        0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,  //
        0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,  //
    };

    // 128比特明文
    uint8_t plaintext[SM4_BLOCK_SIZE] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,  //
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,  //
    };

    // 128比特密文输出
    uint8_t out[SM4_BLOCK_SIZE * 2];
    int outl;

    int main() {
        SM4_CBC_CTX sm4_cbc_ctx;
        uint8_t* outptr = out;
        outl = 0;

        // SM4 CBC初始化
        sm4_cbc_init(key, iv, &sm4_cbc_ctx);
        // SM4 CBC Update 消息
        sm4_cbc_encrypt_update(outptr, &outl, plaintext, sizeof(plaintext),
                            &sm4_cbc_ctx);
        outptr += outl;  // 更新out指针
        // SM4 CBC Final
        sm4_cbc_encrypt_final(outptr, &outl, &sm4_cbc_ctx);
        outptr += outl;  // 更新out指针

        int ciphertext_size = (int)(outptr - out);
        dump_data(out, ciphertext_size);
        //  5d 1f ee 63 f5 eb 8b b5 03 58 0a b8 23 92 5d 55
        //  d1 b0 fc eb 63 b8 b2 4f 3f f5 d9 3a 33 ea d1 70
        return 0;
    }


####################
三、SM4 CTR 模式
####################

.. c:struct:: SM4_CTR_CTX
    
    .. c:var:: SM4_Key sm4key

        SM4 轮密钥

    .. c:var:: uint8_t iv[SM4_BLOCK_SIZE]

        CTR 模式初始向量 iv

    .. c:var:: uint8_t buffer[SM4_FAST_BLOCK_SIZE]
        
        缓冲区

    .. c:var:: int bsize

        buffer 长度

.. note:: 

    SM4 CTR 模式默认不采用填充，输出的密文结果将于明文长度一致，即使明文长度不是 ``BLOCK_SIZE`` 整数倍

.. c:function:: void sm4_ctr_init(uint8_t* key, uint8_t* iv, SM4_CTR_CTX* ctr_ctx);

    SM4 CTR模式初始化

.. c:function:: void sm4_ctr_reset(uint8_t* iv, SM4_CTR_CTX* ctr_ctx);

    SM4 CTR模式Context重置

.. c:function:: void sm4_ctr_encrypt_update(uint8_t* out, int* outl, uint8_t* in, int inl, \
                                            SM4_CTR_CTX* ctr_ctx);

    SM4 CTR加密模式Update数据

.. c:function:: void sm4_ctr_decrypt_update(uint8_t* out, int* outl, uint8_t* in, int inl, \
                                            SM4_CTR_CTX* ctr_ctx);

    SM4 CTR解密模式Update数据

.. c:function:: void sm4_ctr_encrypt_final(uint8_t* out, int* outl, SM4_CTR_CTX* ctr_ctx);

    SM4 CTR加密模式Final

.. c:function:: void sm4_ctr_decrypt_final(uint8_t* out, int* outl, SM4_CTR_CTX* ctr_ctx);

    SM4 CTR解密模式Final