{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GMLib \u652f\u6301\u56fd\u5bc6 SM4/AES-ECB/CBC/GCM\uff0cSM3\uff0cSM2\u7b7e\u540d/\u52a0\u5bc6\uff0cZUC\u7b97\u6cd5 \u7684\u5bc6\u7801\u5e93\uff0c\u6587\u6863\u9875\u9762 https://oldprincess.github.io/gmlib/\uff0c\u9879\u76ee\u5730\u5740 gmlib \u5f00\u53d1\u8fd9\u4e2a\u5e93\u7684\u65f6\u5019\u53c2\u8003\u4e86\u5f88\u591a\u5bc6\u7801\u5e93\uff0c\u4f8b\u5982 Crypto++ \uff0c openssl \uff0c GmSSL \uff0c Oryx Embedded \u4ee5\u53ca JAVA JDK \uff0c\u6240\u4ee5\u5f88\u591a\u5730\u65b9\u90fd\u80fd\u770b\u5230\u8fd9\u4e9b\u5e93\u7684\u5f71\u5b50 \u4e00\u3001\u5feb\u901f\u5f00\u59cb 1.1 \u6587\u4ef6\u76ee\u5f55 \u6574\u4e2a\u9879\u76ee\u4e3b\u8981\u5206\u4e3a4\u90e8\u5206\uff0c include \u76ee\u5f55\u4e3a gmlib \u5e93\u5411\u5916\u66b4\u9732\u7684\u63a5\u53e3\uff0c src \u76ee\u5f55\u4e3a\u5b9e\u73b0\u7684\u6e90\u4ee3\u7801\uff0c test \u76ee\u5f55\u4e3a\u6d4b\u8bd5\u51fd\u6570\uff0c demo \u76ee\u5f55\u4e3a\u4e00\u4e9b\u8c03\u7528\u6837\u4f8b 1.2 \u901a\u8fc7CMake\u7f16\u8bd1\uff08\u63a8\u8350\uff09 \u6d4b\u8bd5\u73af\u58831\uff1a Windows 10 \u7cfb\u7edf\uff0c VS \u7248\u672c2019\uff0c CMake \u7248\u672c3.15 \u6d4b\u8bd5\u73af\u58832\uff1a Ubuntu 18.04.6 LTS \u7cfb\u7edf\uff0c gcc \u7248\u672c7.5.0\uff0c CMake \u7248\u672c3.10.2 \u82e5 Windows \u7535\u8111\u4e2d\u6ca1\u6709\u914d\u7f6e CMake \u73af\u5883\uff0c\u5219\u53ef\u4ece https://cmake.org/download/ \u5904\u4e0b\u8f7d\u5b89\u88c5\u914d\u7f6e \u62f7\u8d1d gmlib \u9879\u76ee\u81f3\u672c\u673a(\u4e5f\u53ef\u4ee5\u901a\u8fc7\u4e0b\u8f7dzip\u5305\u7684\u65b9\u5f0f\u62f7\u8d1d) git clone https://github.com/oldprincess/gmlib.git \u6267\u884c\u4e0b\u8ff0\u547d\u4ee4 # \u8fdb\u5165 gmlib \u76ee\u5f55 cd gmlib # \u521b\u5efa build \u76ee\u5f55\uff0c\u907f\u514d\u6c61\u67d3\u6e90\u4ee3\u7801 mkdir build cd build \u6267\u884ccmake\uff0c\u4ee5Release\u6a21\u5f0f\u7f16\u8bd1 # linux cmake .. -DCMAKE_BUILD_TYPE = Release cmake --build . # Windows(VS) cmake .. cmake --build . --config release \u82e5\u7f16\u8bd1\u6210\u529f\uff0c\u5219\u5e94\u8be5\u5728 build \u76ee\u5f55\u4e0b\u751f\u6210\u7ed3\u679c\u6587\u4ef6\uff0c\u5728\u5176\u4e0b\u7684 bin \u548c lib \u76ee\u5f55\u4e3a\u751f\u6210\u7684\u6d4b\u8bd5\u6587\u4ef6\u4e0elib\u6587\u4ef6 \u5728\u63a7\u5236\u53f0\u4e2d\u6267\u884c bin \u76ee\u5f55\u4e0b\u7f16\u8bd1\u51fa\u7684\u6d4b\u8bd5\u6587\u4ef6 gmlib-test \u5e94\u5f53\u53ef\u5728\u63a7\u5236\u53f0\u4e2d\u770b\u5230\u8f93\u51fa test finish! \uff0c\u8bf4\u660e\u6d4b\u8bd5\u7ed3\u679c\u6b63\u786e \u6ce8 \uff1a\u5728 linux \u7cfb\u7edf\u4e2d\u7f16\u8bd1\u6d41\u7a0b\u540c\u4e0a \u4e8c\u3001GMLib \u5e93\u4f7f\u7528 \u4ee5 1.2 \u4e2d\u7684 cmake \u65b9\u5f0f\u7f16\u8bd1\u4e3a\u4f8b\uff0c\u7f16\u8bd1\u5b8c\u6210\u540e\u751f\u6210\u7684\u5e93\u6587\u4ef6\u4f4d\u4e8e gmlib/build/lib \u76ee\u5f55\uff0c\u5e93\u7684\u540d\u79f0\u5747\u4e3a gmlib \u3002 \u9519\u8bef\u4fe1\u606f\u8f93\u51fa\u81f3 stderr \uff0c\u4f8b\u5982\u5982\u4e0b\u4ee3\u7801\uff1a #include <gmlib/bint.h> int main () { BINT x ; // \u58f0\u660e\u5927\u6574\u6570\u53d8\u91cf // \u4ece\u5b57\u7b26\u4e32\u4e2d\u4ee510\u8fdb\u5236\u8bfb\u5165\u5927\u6574\u6570 bint_from_str ( & x , \"a\" , 10 ); return 0 ; } \u63a7\u5236\u53f0\u4e2d\u5c06\u63d0\u793a [ Error ] Bad string input, need [ 0 , 9 ] , get a. File ` .. \\s rc \\b int \\b int_cast.c ` , line 68 , in ` bint_from_str ` \u8be5\u9519\u8bef\u63d0\u793a\u662f\u7531 GMLIB_DEBUG \u5b8f\u63a7\u5236\uff0c\u82e5\u60f3\u5173\u95ed\u8be5\u63d0\u793a\uff0c\u53ef\u4fee\u6539 CMakeLists.txt \u6587\u4ef6\uff0c\u5c06\u8be5\u884c\u6ce8\u91ca set ( CMAKE_C_FLAGS -DGMLIB_DEBUG ) \u518d\u91cd\u65b0\u7f16\u8bd1\u5de5\u7a0b \u66f4\u591a\u4f7f\u7528\u6837\u4f8b\u8bf7\u53c2\u8003docs\u6587\u6863\u548cdemo\u76ee\u5f55 \u4e09\u3001\u5176\u5b83 \u4e3a\u4ec0\u4e48\u8981\u5199\u8fd9\u4e2a\u5bc6\u7801\u5e93 \uff1a \u60f3\u81ea\u5df1\u9020\u4e2a\u8f6e\u5b50\uff0c\u5982\u679c\u53ef\u4ee5\u7684\u8bdd\u53ef\u4ee5\u65b9\u4fbf\u540e\u4eba\u5bf9\u5bc6\u7801\u5b66\u5b9e\u73b0\u8fd9\u5757\u7684\u5b66\u4e60\u3002 \u6211\u6700\u521d\u5b66\u4e60\u7b97\u6cd5\u6211\u662f\u901a\u8fc7 openssl \u5e93\u5b66\u4e60\u7684\uff0c openssl \u5e93\u4ee3\u7801\u98ce\u683c\u5bf9\u6211\u800c\u8a00\u8fc7\u4e8e\u6666\u6da9\u590d\u6742\u3002\u4e4b\u540e\u627e\u5230\u4e86\u9605\u8bfb\u8d77\u6765\u66f4\u4e3a\u6613\u61c2\u7684 oryx-embedded \uff08\u4e00\u4e2a\u5d4c\u5165\u5f0f\u7684\u5bc6\u7801\u5e93\uff09\u3002\u5728\u5b66\u4e60\u5927\u6574\u6570\u8fd0\u7b97\u65f6\u6211\u662f\u9605\u8bfb Java JDK \u7684\u6e90\u7801\u5b66\u4e60\u7684\uff0c\u867d\u7136\u4ee3\u7801\u98ce\u683c\u4f18\u79c0\uff0c\u4f46 Java \u4e2d\u5168\u90e8\u6e90\u7801\u96c6\u4e2d\u5728\u4e00\u4e2a\u6587\u4ef6\u4e2d\uff0c\u51fd\u6570\u8c03\u7528\u5173\u7cfb\u4e0d\u6613\u634b\u6e05\uff0c\u800c\u4e14\u82f1\u6587\u6587\u6863\u548c\u4ee3\u7801\u5bf9\u6211\u800c\u8a00\u9605\u8bfb\u8d77\u6765\u8fdc\u4e0d\u53ca\u4e2d\u6587\u65b9\u4fbf\u3002 \u540e\u7eed\u8fd9\u4e2a\u5e93\u7684\u5f00\u53d1\u65b9\u5411 \uff1a \u540e\u7eed\u4e3b\u8981\u968f\u7740\u81ea\u5df1\u7684\u559c\u597d\u5f00\u53d1\uff0c\u9884\u8ba1\u5148\u5c06\u56fd\u5bc6\u6807\u51c6\u7684\u7b97\u6cd5\u5168\u90e8\u5199\u5b8c\uff0c\u4e4b\u540e\u9884\u8ba1\u589e\u52a0\u5176\u5b83\u7684\u5de5\u4f5c\u6a21\u5f0f\u548c\u5bc6\u7801\u7b97\u6cd5\uff0c\u518d\u8fdb\u884c\u4e9b\u6548\u7387\u4e0a\u7684\u4f18\u5316\u3002","title":"\u5feb\u901f\u5f00\u59cb"},{"location":"#gmlib","text":"\u652f\u6301\u56fd\u5bc6 SM4/AES-ECB/CBC/GCM\uff0cSM3\uff0cSM2\u7b7e\u540d/\u52a0\u5bc6\uff0cZUC\u7b97\u6cd5 \u7684\u5bc6\u7801\u5e93\uff0c\u6587\u6863\u9875\u9762 https://oldprincess.github.io/gmlib/\uff0c\u9879\u76ee\u5730\u5740 gmlib \u5f00\u53d1\u8fd9\u4e2a\u5e93\u7684\u65f6\u5019\u53c2\u8003\u4e86\u5f88\u591a\u5bc6\u7801\u5e93\uff0c\u4f8b\u5982 Crypto++ \uff0c openssl \uff0c GmSSL \uff0c Oryx Embedded \u4ee5\u53ca JAVA JDK \uff0c\u6240\u4ee5\u5f88\u591a\u5730\u65b9\u90fd\u80fd\u770b\u5230\u8fd9\u4e9b\u5e93\u7684\u5f71\u5b50","title":"GMLib"},{"location":"#_1","text":"","title":"\u4e00\u3001\u5feb\u901f\u5f00\u59cb"},{"location":"#11","text":"\u6574\u4e2a\u9879\u76ee\u4e3b\u8981\u5206\u4e3a4\u90e8\u5206\uff0c include \u76ee\u5f55\u4e3a gmlib \u5e93\u5411\u5916\u66b4\u9732\u7684\u63a5\u53e3\uff0c src \u76ee\u5f55\u4e3a\u5b9e\u73b0\u7684\u6e90\u4ee3\u7801\uff0c test \u76ee\u5f55\u4e3a\u6d4b\u8bd5\u51fd\u6570\uff0c demo \u76ee\u5f55\u4e3a\u4e00\u4e9b\u8c03\u7528\u6837\u4f8b","title":"1.1 \u6587\u4ef6\u76ee\u5f55"},{"location":"#12-cmake","text":"\u6d4b\u8bd5\u73af\u58831\uff1a Windows 10 \u7cfb\u7edf\uff0c VS \u7248\u672c2019\uff0c CMake \u7248\u672c3.15 \u6d4b\u8bd5\u73af\u58832\uff1a Ubuntu 18.04.6 LTS \u7cfb\u7edf\uff0c gcc \u7248\u672c7.5.0\uff0c CMake \u7248\u672c3.10.2 \u82e5 Windows \u7535\u8111\u4e2d\u6ca1\u6709\u914d\u7f6e CMake \u73af\u5883\uff0c\u5219\u53ef\u4ece https://cmake.org/download/ \u5904\u4e0b\u8f7d\u5b89\u88c5\u914d\u7f6e \u62f7\u8d1d gmlib \u9879\u76ee\u81f3\u672c\u673a(\u4e5f\u53ef\u4ee5\u901a\u8fc7\u4e0b\u8f7dzip\u5305\u7684\u65b9\u5f0f\u62f7\u8d1d) git clone https://github.com/oldprincess/gmlib.git \u6267\u884c\u4e0b\u8ff0\u547d\u4ee4 # \u8fdb\u5165 gmlib \u76ee\u5f55 cd gmlib # \u521b\u5efa build \u76ee\u5f55\uff0c\u907f\u514d\u6c61\u67d3\u6e90\u4ee3\u7801 mkdir build cd build \u6267\u884ccmake\uff0c\u4ee5Release\u6a21\u5f0f\u7f16\u8bd1 # linux cmake .. -DCMAKE_BUILD_TYPE = Release cmake --build . # Windows(VS) cmake .. cmake --build . --config release \u82e5\u7f16\u8bd1\u6210\u529f\uff0c\u5219\u5e94\u8be5\u5728 build \u76ee\u5f55\u4e0b\u751f\u6210\u7ed3\u679c\u6587\u4ef6\uff0c\u5728\u5176\u4e0b\u7684 bin \u548c lib \u76ee\u5f55\u4e3a\u751f\u6210\u7684\u6d4b\u8bd5\u6587\u4ef6\u4e0elib\u6587\u4ef6 \u5728\u63a7\u5236\u53f0\u4e2d\u6267\u884c bin \u76ee\u5f55\u4e0b\u7f16\u8bd1\u51fa\u7684\u6d4b\u8bd5\u6587\u4ef6 gmlib-test \u5e94\u5f53\u53ef\u5728\u63a7\u5236\u53f0\u4e2d\u770b\u5230\u8f93\u51fa test finish! \uff0c\u8bf4\u660e\u6d4b\u8bd5\u7ed3\u679c\u6b63\u786e \u6ce8 \uff1a\u5728 linux \u7cfb\u7edf\u4e2d\u7f16\u8bd1\u6d41\u7a0b\u540c\u4e0a","title":"1.2 \u901a\u8fc7CMake\u7f16\u8bd1\uff08\u63a8\u8350\uff09"},{"location":"#gmlib_1","text":"\u4ee5 1.2 \u4e2d\u7684 cmake \u65b9\u5f0f\u7f16\u8bd1\u4e3a\u4f8b\uff0c\u7f16\u8bd1\u5b8c\u6210\u540e\u751f\u6210\u7684\u5e93\u6587\u4ef6\u4f4d\u4e8e gmlib/build/lib \u76ee\u5f55\uff0c\u5e93\u7684\u540d\u79f0\u5747\u4e3a gmlib \u3002 \u9519\u8bef\u4fe1\u606f\u8f93\u51fa\u81f3 stderr \uff0c\u4f8b\u5982\u5982\u4e0b\u4ee3\u7801\uff1a #include <gmlib/bint.h> int main () { BINT x ; // \u58f0\u660e\u5927\u6574\u6570\u53d8\u91cf // \u4ece\u5b57\u7b26\u4e32\u4e2d\u4ee510\u8fdb\u5236\u8bfb\u5165\u5927\u6574\u6570 bint_from_str ( & x , \"a\" , 10 ); return 0 ; } \u63a7\u5236\u53f0\u4e2d\u5c06\u63d0\u793a [ Error ] Bad string input, need [ 0 , 9 ] , get a. File ` .. \\s rc \\b int \\b int_cast.c ` , line 68 , in ` bint_from_str ` \u8be5\u9519\u8bef\u63d0\u793a\u662f\u7531 GMLIB_DEBUG \u5b8f\u63a7\u5236\uff0c\u82e5\u60f3\u5173\u95ed\u8be5\u63d0\u793a\uff0c\u53ef\u4fee\u6539 CMakeLists.txt \u6587\u4ef6\uff0c\u5c06\u8be5\u884c\u6ce8\u91ca set ( CMAKE_C_FLAGS -DGMLIB_DEBUG ) \u518d\u91cd\u65b0\u7f16\u8bd1\u5de5\u7a0b \u66f4\u591a\u4f7f\u7528\u6837\u4f8b\u8bf7\u53c2\u8003docs\u6587\u6863\u548cdemo\u76ee\u5f55","title":"\u4e8c\u3001GMLib \u5e93\u4f7f\u7528"},{"location":"#_2","text":"\u4e3a\u4ec0\u4e48\u8981\u5199\u8fd9\u4e2a\u5bc6\u7801\u5e93 \uff1a \u60f3\u81ea\u5df1\u9020\u4e2a\u8f6e\u5b50\uff0c\u5982\u679c\u53ef\u4ee5\u7684\u8bdd\u53ef\u4ee5\u65b9\u4fbf\u540e\u4eba\u5bf9\u5bc6\u7801\u5b66\u5b9e\u73b0\u8fd9\u5757\u7684\u5b66\u4e60\u3002 \u6211\u6700\u521d\u5b66\u4e60\u7b97\u6cd5\u6211\u662f\u901a\u8fc7 openssl \u5e93\u5b66\u4e60\u7684\uff0c openssl \u5e93\u4ee3\u7801\u98ce\u683c\u5bf9\u6211\u800c\u8a00\u8fc7\u4e8e\u6666\u6da9\u590d\u6742\u3002\u4e4b\u540e\u627e\u5230\u4e86\u9605\u8bfb\u8d77\u6765\u66f4\u4e3a\u6613\u61c2\u7684 oryx-embedded \uff08\u4e00\u4e2a\u5d4c\u5165\u5f0f\u7684\u5bc6\u7801\u5e93\uff09\u3002\u5728\u5b66\u4e60\u5927\u6574\u6570\u8fd0\u7b97\u65f6\u6211\u662f\u9605\u8bfb Java JDK \u7684\u6e90\u7801\u5b66\u4e60\u7684\uff0c\u867d\u7136\u4ee3\u7801\u98ce\u683c\u4f18\u79c0\uff0c\u4f46 Java \u4e2d\u5168\u90e8\u6e90\u7801\u96c6\u4e2d\u5728\u4e00\u4e2a\u6587\u4ef6\u4e2d\uff0c\u51fd\u6570\u8c03\u7528\u5173\u7cfb\u4e0d\u6613\u634b\u6e05\uff0c\u800c\u4e14\u82f1\u6587\u6587\u6863\u548c\u4ee3\u7801\u5bf9\u6211\u800c\u8a00\u9605\u8bfb\u8d77\u6765\u8fdc\u4e0d\u53ca\u4e2d\u6587\u65b9\u4fbf\u3002 \u540e\u7eed\u8fd9\u4e2a\u5e93\u7684\u5f00\u53d1\u65b9\u5411 \uff1a \u540e\u7eed\u4e3b\u8981\u968f\u7740\u81ea\u5df1\u7684\u559c\u597d\u5f00\u53d1\uff0c\u9884\u8ba1\u5148\u5c06\u56fd\u5bc6\u6807\u51c6\u7684\u7b97\u6cd5\u5168\u90e8\u5199\u5b8c\uff0c\u4e4b\u540e\u9884\u8ba1\u589e\u52a0\u5176\u5b83\u7684\u5de5\u4f5c\u6a21\u5f0f\u548c\u5bc6\u7801\u7b97\u6cd5\uff0c\u518d\u8fdb\u884c\u4e9b\u6548\u7387\u4e0a\u7684\u4f18\u5316\u3002","title":"\u4e09\u3001\u5176\u5b83"},{"location":"bint/","text":"\u5927\u6570\u5e93 BINT file: gmlib/bint.h Warning \u4e3a\u4e86\u7b80\u4fbf\uff0c\u793a\u4f8b\u4ee3\u7801\u4e2d\u5e76\u672a\u8fdb\u884c\u9519\u8bef\u5904\u7406\uff0c \u5b9e\u9645\u60c5\u51b5\u4e0b\u5e94\u5f53\u68c0\u67e5\u51fd\u6570\u8fd4\u56de\u503c\uff0c\u9632\u6b62\u53d1\u751f\u5f02\u5e38 \u53c2\u8003\u8d44\u6599 The Art of Computer Programming (TAOCP), Donald Knuth JDK \u5927\u6574\u6570\u8fd0\u7b97 MutableBigInteger \u548c BigInteger openssl 3.0 \u5927\u6574\u6570 bn \u6a21\u5757 \u5927\u6574\u6570\u7ed3\u6784 /// \u5927\u6574\u6570BINT\u6700\u5927\u6bd4\u7279\u6570 #define GMLIB_BINT_BITS 512 /// \u5927\u6574\u6570BINT\u6700\u5927\u5b57\u6570\uff0832bit\u4e3a\u4e00\u4e2a\u5b57\uff09 #define GMLIB_BINT_SIZE (GMLIB_BINT_BITS / 32) typedef struct BINT { uint32_t d [ GMLIB_BINT_SIZE ]; // GMLIB_BINT_BITS \u5185\u5b58\u7a7a\u95f4 int sign ; // \u7b26\u53f7\uff08-1\u8d1f\u6570\uff0c1\u6b63\u6570\uff0c0\u96f6\uff09 int dsize ; // \u6570\u636e\u957f\u5ea6 } BINT ; \u4e00\u3001\u5927\u6574\u6570\u8bfb\u5165\u4e0e\u8f93\u51fa 1.1 \u5b57\u7b26\u4e32\u8f6c\u5316 \u4ece\u5b57\u7b26\u4e32\u4e2d\u52a0\u8f7d\u5927\u6574\u6570 int bint_from_str ( BINT * n , char * str , int radix ); \u5b57\u7b26\u4e32\u5ffd\u7565\u5927\u5c0f\u5199\uff0c\u4e14\u53ef\u4f7f\u7528 _ \u4f5c\u4e3a\u5206\u9694\u7b26\u4ee5\u4fbf\u9605\u8bfb Example BINT x ; bint_from_str ( & x , \"123456\" , 10 ); // x = 123456 bint_from_str ( & x , \"-123456\" , 10 ); // x = -123456 bint_from_str ( & x , \"ABCDEF\" , 16 ); // x = 0xABCDEF bint_from_str ( & x , \"abcd_EFGH\" , 16 ); // x = 0xABCDEFGH \u5927\u6574\u6570\u8f6c\u5b57\u7b26\u4e32 int bint_to_str ( BINT * n , char * str , int radix ); Example BINT x ; char s [ GMLIB_BINT_BITS + 2 ]; bint_from_str ( & x , \"123456\" , 10 ); // x = 123456 bint_to_str ( & x , s , 10 ); // s = \"123456\" printf ( \"x=%s \\n \" , s ); // x = 123456 bint_to_str ( & x , s , 16 ); // s = \"1E240\" printf ( \"x=0x%s \\n \" , s ); // x = 0x1E240 \u5927\u6574\u6570\u8f6c\u5b57\u7b26\u4e32\uff08\u975e\u7ebf\u7a0b\u5b89\u5168\uff0c\u7528\u4e8e\u6253\u5370\u8f93\u51fa\uff09 char * bint_fast_to_str ( BINT * n , int radix ); Example BINT x ; bint_from_str ( & x , \"123456\" , 10 ); // x=123456 printf ( \"x=%s \\n \" , bint_fast_to_str ( & x , 10 )); // x=123456 Warning \u51fd\u6570 bint_fast_to_str \u5e94\u5f53\u53ea\u7528\u4e8e\u8f93\u51fa\u6570\u636e\uff0c\u4e14\u4e00\u4e2a printf \u4e2d\u4ec5\u80fd\u8c03\u7528\u4e00\u6b21\u8be5\u51fd\u6570\uff0c\u50cf\u5982\u4e0b\u7684\u4ee3\u7801\u5c06\u4f1a\u4ea7\u751f\u9519\u8bef\u7684\u8f93\u51fa\u7ed3\u679c // error output printf ( \"x=%s, y=%s \\n \" , bint_fast_to_str ( & x , 10 ), bint_fast_to_str ( & y , 10 )); 1.2 \u6574\u6570\u8f6c\u5316 \u4ece\u6574\u6570\u4e2d\u8bfb\u5165\u5927\u6574\u6570 void bint_from_u32 ( BINT * n , uint32_t u ); \u5927\u6574\u6570\u8f6c32\u4f4d\u6574\u6570 int bint_to_u32 ( uint32_t * u , BINT * n ); Example BINT x ; uint32_t u1 = 123456 , u2 = 0 ; bint_from_u32 ( & x , u1 ); // x=123456 bint_to_u32 ( & u2 , & x ); // u2=123456 // u1=123456, u2=123456, x=123456 printf ( \"u1=%d, u2=%d, x=%s \\n \" , u1 , u2 , bint_fast_to_str ( & x , 10 )); 1.3 \u5b57\u8282\u4e32\u8f6c\u5316 \u5b8f\u5b9a\u4e49 \u503c \u542b\u4e49 BINT_BIG_ENDIAN 1 \u5927\u7aef\u6a21\u5f0f BINT_LITTLE_ENDIAN 0 \u5c0f\u7aef\u6a21\u5f0f \u4ece\u5b57\u8282\u4e32\u4e2d\u8bfb\u53d6\u5927\u6574\u6570 int bint_from_bytes ( BINT * n , uint8_t * b , int bsize , int endian ); Example BINT x ; uint8_t b [] = { 0x12 , 0x34 , 0x56 , 0x78 }; // x=0x12345678 bint_from_bytes ( & x , b , sizeof ( b ), BINT_BIG_ENDIAN ); printf ( \"x=0x%s \\n \" , bint_fast_to_str ( & x , 16 )); // x=0x78563412 bint_from_bytes ( & x , b , sizeof ( b ), BINT_LITTLE_ENDIAN ); printf ( \"x=0x%s \\n \" , bint_fast_to_str ( & x , 16 )); \u5927\u6574\u6570\u8f6c\u5b57\u8282\u4e32 int bint_to_bytes ( BINT * n , uint8_t * b , int bsize , int endian ); Example BINT x ; uint8_t b [ 10 ]; bint_from_str ( & x , \"01_23_45_67\" , 16 ); // x=0x01234567 bint_to_bytes ( & x , b , 4 , BINT_BIG_ENDIAN ); dump_data ( b , 4 ); // 01 23 45 67 bint_to_bytes ( & x , b , 6 , BINT_BIG_ENDIAN ); dump_data ( b , 6 ); // 00 00 01 23 45 67 Note \u50cf\u4e0a\u9762\u7684\u4ee3\u7801\u90a3\u6837\uff0c\u5f53\u5b57\u8282\u4e32\u957f\u5ea6\u8d85\u8fc7\u8868\u793a\u5927\u6574\u6570 BINT \u6240\u9700\u8981\u7684\u5927\u5c0f\u65f6\uff0c\u4f1a\u9ed8\u8ba4\u88650\uff0c\u5efa\u8bae\u91c7\u7528 bint_bytes_len \u51fd\u6570\u83b7\u53d6\u5927\u6574\u6570\u6240\u9700\u8981\u7684\u5b57\u8282\u5927\u5c0f\uff0c\u5982\u4e0b\u6240\u793a Example int bsize = bint_bytes_len ( & x ); // 4 bint_to_bytes ( & x , b , bsize , BINT_BIG_ENDIAN ); dump_data ( b , bsize ); // 01 23 45 67 \u4e8c\u3001\u5927\u6574\u6570\u8fd0\u7b97 2.1 \u52a0\u51cf\u6cd5 \u5927\u6574\u6570\u52a0\u6cd5 int bint_add ( BINT * r , BINT * n1 , BINT * n2 ); \u5927\u6574\u6570\u51cf\u6cd5 int bint_sub ( BINT * r , BINT * n1 , BINT * n2 ); Example BINT x , y , z1 , z2 ; bint_from_str ( & x , \"1000\" , 10 ); // x=1000 bint_from_str ( & y , \"2000\" , 10 ); // y=2000 bint_add ( & z1 , & x , & y ); // z1=x+y bint_sub ( & z2 , & x , & y ); // z2=x-y // x+y=3000 // x-y=-1000 printf ( \"x+y=%s \\n \" , bint_fast_to_str ( & z1 , 10 )); printf ( \"x-y=%s \\n \" , bint_fast_to_str ( & z2 , 10 )); 2.2 \u4e58\u6cd5 \u5927\u6574\u6570\u4e58\u6cd5 int bint_mul ( BINT * r , BINT * n1 , BINT * n2 ); \u5927\u6574\u6570\u4e8c\u6b21\u5e42 int bint_sqr ( BINT * r , BINT * n ); \u5927\u6574\u6570\u4e58\u6cd5 int bint_mul_u32 ( BINT * r , BINT * n1 , uint32_t n2 ); Example BINT x , z1 , z2 , z3 ; bint_from_str ( & x , \"1000\" , 10 ); // x=1000 bint_mul ( & z1 , & x , & x ); // z1=x*x bint_sqr ( & z2 , & x ); // z2=x^2 bint_mul_u32 ( & z3 , & x , 1000 ); // z3=x*1000 // x*x = 1000000 // x^2 = 1000000 // x*1000= 1000000 printf ( \"x*x=%s \\n \" , bint_fast_to_str ( & z1 , 10 )); printf ( \"x^2=%s \\n \" , bint_fast_to_str ( & z2 , 10 )); printf ( \"x*1000=%s \\n \" , bint_fast_to_str ( & z3 , 10 )); 2.3 \u9664\u6cd5 \u5927\u6574\u6570\u9664\u6cd5 int bint_divmod ( BINT * q , BINT * r , BINT * n1 , BINT * n2 ); \u5927\u6574\u6570\u9664\u6cd5 int bint_divmod_u32 ( BINT * q , uint32_t * r , BINT * n1 , uint32_t n2 ); Example BINT x , y , z1 , z2 ; uint32_t rem ; bint_from_str ( & x , \"1001\" , 10 ); // x=1001 bint_from_str ( & y , \"50\" , 10 ); // y=50 bint_divmod ( & z1 , & z2 , & x , & y ); // x div y = 20, x mod y = 1 printf ( \"x div y=%s \\n \" , bint_fast_to_str ( & z1 , 10 )); printf ( \"x mod y=%s \\n \" , bint_fast_to_str ( & z2 , 10 )); // same bint_divmod ( & z1 , NULL , & x , & y ); // \u4e22\u5f03\u4f59\u6570 bint_divmod ( NULL , & z2 , & x , & y ); // \u4e22\u5f03\u5546 // also like bint_divmod_u32 ( & z1 , & rem , & x , 50 ); 2.4 \u5e42 \u5927\u6574\u6570\u6c42\u5e42 int bint_pow ( BINT * r , BINT * n , BINT * e , BINT * mod ); \u5927\u6574\u6570\u6c42\u5e42 int bint_pow_u32 ( BINT * r , BINT * n , uint32_t e , BINT * mod ); Example BINT x , mod , z1 , z2 ; bint_from_str ( & x , \"1001\" , 10 ); // x=1001 // x^3 bint_pow ( & z1 , & x , & BINT_THREE , NULL ); bint_pow_u32 ( & z2 , & x , 3 , NULL ); // z1=1003003001, z2=1003003001 printf ( \"z1=%s \\n \" , bint_fast_to_str ( & z1 , 10 )); printf ( \"z2=%s \\n \" , bint_fast_to_str ( & z2 , 10 )); bint_from_str ( & mod , \"1000\" , 10 ); // mod=1000 bint_pow_u32 ( & z1 , & x , 3 , & mod ); // x^3 mod 1000 // z1=1 printf ( \"z1=%s \\n \" , bint_fast_to_str ( & z1 , 10 )); 2.5 \u7b97\u6570\u79fb\u4f4d \u5927\u6574\u6570\u903b\u8f91\uff08\u7b97\u6570\uff09\u5de6\u79fb int bint_sll ( BINT * r , BINT * n , int bits ); \u5927\u6574\u6570\u7b97\u6570\u53f3\u79fb int bint_sra ( BINT * r , BINT * n , int bits ); Example BINT x , z ; bint_from_str ( & x , \"1110\" , 2 ); // x=0b1110 bint_sll ( & z , & x , 3 ); // z=0b1110000 printf ( \"z=%s \\n \" , bint_fast_to_str ( & z , 2 )); bint_sra ( & z , & x , 2 ); // z=11 printf ( \"z=%s \\n \" , bint_fast_to_str ( & z , 2 )); \u4e09\u3001\u5927\u6574\u6570\u529f\u80fd\u51fd\u6570 3.1 \u6bd4\u8f83\u51fd\u6570 \u5927\u6574\u6570\u6bd4\u8f83 int bint_cmp ( BINT * n1 , BINT * n2 ); \u662f\u5426\u4e3a\u96f6 inline int bint_is_zero ( BINT * n ); \u662f\u5426\u4e3a\u8d1f inline int bint_is_neg ( BINT * n ); \u662f\u5426\u4e3a\u6b63 inline int bint_is_pos ( BINT * n ); \u662f\u5426\u662f\u5947\u6570 inline int bint_is_odd ( BINT * n ); 3.2 \u8bbe\u7f6e/\u62f7\u8d1d\u51fd\u6570 \u8bbe\u7f6e\u5927\u6574\u6570\u4e3a\u96f6 inline void bint_set_zero ( BINT * n ); \u5927\u6574\u6570\u62f7\u8d1d void bint_copy ( BINT * r , BINT * n ); \u5927\u6574\u6570\u53d6\u8d1f void bint_neg ( BINT * r , BINT * n ); \u5927\u6574\u6570\u53d6\u7edd\u5bf9\u503c void bint_abs ( BINT * r , BINT * n ); 3.3 \u6742\u9879/\u8f85\u52a9\u51fd\u6570 \u5927\u6574\u6570\u7684\u5b57\u8282\u6570 int bint_bytes_len ( BINT * n ); \u5927\u6574\u6570\u7684\u6bd4\u7279\u6570 int bint_bits_len ( BINT * n ); \u5927\u6574\u6570\u67d0\u4e00\u6bd4\u7279\u4f4d\u6570\u503c int bint_bits_at ( BINT * n , int index ); Example BINT x ; bint_from_str ( & x , \"11100\" , 2 ); // x=0b11100 int bits = bint_bits_len ( & x ); // bits=5 for ( int i = bits - 1 ; i >= 0 ; i -- ) { // 1 1 1 0 0 printf ( \"%d \" , bint_bits_at ( & x , i )); } puts ( \"\" );","title":"\u57fa\u672c\u8fd0\u7b97"},{"location":"bint/#bint","text":"file: gmlib/bint.h Warning \u4e3a\u4e86\u7b80\u4fbf\uff0c\u793a\u4f8b\u4ee3\u7801\u4e2d\u5e76\u672a\u8fdb\u884c\u9519\u8bef\u5904\u7406\uff0c \u5b9e\u9645\u60c5\u51b5\u4e0b\u5e94\u5f53\u68c0\u67e5\u51fd\u6570\u8fd4\u56de\u503c\uff0c\u9632\u6b62\u53d1\u751f\u5f02\u5e38 \u53c2\u8003\u8d44\u6599 The Art of Computer Programming (TAOCP), Donald Knuth JDK \u5927\u6574\u6570\u8fd0\u7b97 MutableBigInteger \u548c BigInteger openssl 3.0 \u5927\u6574\u6570 bn \u6a21\u5757 \u5927\u6574\u6570\u7ed3\u6784 /// \u5927\u6574\u6570BINT\u6700\u5927\u6bd4\u7279\u6570 #define GMLIB_BINT_BITS 512 /// \u5927\u6574\u6570BINT\u6700\u5927\u5b57\u6570\uff0832bit\u4e3a\u4e00\u4e2a\u5b57\uff09 #define GMLIB_BINT_SIZE (GMLIB_BINT_BITS / 32) typedef struct BINT { uint32_t d [ GMLIB_BINT_SIZE ]; // GMLIB_BINT_BITS \u5185\u5b58\u7a7a\u95f4 int sign ; // \u7b26\u53f7\uff08-1\u8d1f\u6570\uff0c1\u6b63\u6570\uff0c0\u96f6\uff09 int dsize ; // \u6570\u636e\u957f\u5ea6 } BINT ;","title":"\u5927\u6570\u5e93 BINT"},{"location":"bint/#_1","text":"","title":"\u4e00\u3001\u5927\u6574\u6570\u8bfb\u5165\u4e0e\u8f93\u51fa"},{"location":"bint/#11","text":"\u4ece\u5b57\u7b26\u4e32\u4e2d\u52a0\u8f7d\u5927\u6574\u6570 int bint_from_str ( BINT * n , char * str , int radix ); \u5b57\u7b26\u4e32\u5ffd\u7565\u5927\u5c0f\u5199\uff0c\u4e14\u53ef\u4f7f\u7528 _ \u4f5c\u4e3a\u5206\u9694\u7b26\u4ee5\u4fbf\u9605\u8bfb Example BINT x ; bint_from_str ( & x , \"123456\" , 10 ); // x = 123456 bint_from_str ( & x , \"-123456\" , 10 ); // x = -123456 bint_from_str ( & x , \"ABCDEF\" , 16 ); // x = 0xABCDEF bint_from_str ( & x , \"abcd_EFGH\" , 16 ); // x = 0xABCDEFGH \u5927\u6574\u6570\u8f6c\u5b57\u7b26\u4e32 int bint_to_str ( BINT * n , char * str , int radix ); Example BINT x ; char s [ GMLIB_BINT_BITS + 2 ]; bint_from_str ( & x , \"123456\" , 10 ); // x = 123456 bint_to_str ( & x , s , 10 ); // s = \"123456\" printf ( \"x=%s \\n \" , s ); // x = 123456 bint_to_str ( & x , s , 16 ); // s = \"1E240\" printf ( \"x=0x%s \\n \" , s ); // x = 0x1E240 \u5927\u6574\u6570\u8f6c\u5b57\u7b26\u4e32\uff08\u975e\u7ebf\u7a0b\u5b89\u5168\uff0c\u7528\u4e8e\u6253\u5370\u8f93\u51fa\uff09 char * bint_fast_to_str ( BINT * n , int radix ); Example BINT x ; bint_from_str ( & x , \"123456\" , 10 ); // x=123456 printf ( \"x=%s \\n \" , bint_fast_to_str ( & x , 10 )); // x=123456 Warning \u51fd\u6570 bint_fast_to_str \u5e94\u5f53\u53ea\u7528\u4e8e\u8f93\u51fa\u6570\u636e\uff0c\u4e14\u4e00\u4e2a printf \u4e2d\u4ec5\u80fd\u8c03\u7528\u4e00\u6b21\u8be5\u51fd\u6570\uff0c\u50cf\u5982\u4e0b\u7684\u4ee3\u7801\u5c06\u4f1a\u4ea7\u751f\u9519\u8bef\u7684\u8f93\u51fa\u7ed3\u679c // error output printf ( \"x=%s, y=%s \\n \" , bint_fast_to_str ( & x , 10 ), bint_fast_to_str ( & y , 10 ));","title":"1.1 \u5b57\u7b26\u4e32\u8f6c\u5316"},{"location":"bint/#12","text":"\u4ece\u6574\u6570\u4e2d\u8bfb\u5165\u5927\u6574\u6570 void bint_from_u32 ( BINT * n , uint32_t u ); \u5927\u6574\u6570\u8f6c32\u4f4d\u6574\u6570 int bint_to_u32 ( uint32_t * u , BINT * n ); Example BINT x ; uint32_t u1 = 123456 , u2 = 0 ; bint_from_u32 ( & x , u1 ); // x=123456 bint_to_u32 ( & u2 , & x ); // u2=123456 // u1=123456, u2=123456, x=123456 printf ( \"u1=%d, u2=%d, x=%s \\n \" , u1 , u2 , bint_fast_to_str ( & x , 10 ));","title":"1.2 \u6574\u6570\u8f6c\u5316"},{"location":"bint/#13","text":"\u5b8f\u5b9a\u4e49 \u503c \u542b\u4e49 BINT_BIG_ENDIAN 1 \u5927\u7aef\u6a21\u5f0f BINT_LITTLE_ENDIAN 0 \u5c0f\u7aef\u6a21\u5f0f \u4ece\u5b57\u8282\u4e32\u4e2d\u8bfb\u53d6\u5927\u6574\u6570 int bint_from_bytes ( BINT * n , uint8_t * b , int bsize , int endian ); Example BINT x ; uint8_t b [] = { 0x12 , 0x34 , 0x56 , 0x78 }; // x=0x12345678 bint_from_bytes ( & x , b , sizeof ( b ), BINT_BIG_ENDIAN ); printf ( \"x=0x%s \\n \" , bint_fast_to_str ( & x , 16 )); // x=0x78563412 bint_from_bytes ( & x , b , sizeof ( b ), BINT_LITTLE_ENDIAN ); printf ( \"x=0x%s \\n \" , bint_fast_to_str ( & x , 16 )); \u5927\u6574\u6570\u8f6c\u5b57\u8282\u4e32 int bint_to_bytes ( BINT * n , uint8_t * b , int bsize , int endian ); Example BINT x ; uint8_t b [ 10 ]; bint_from_str ( & x , \"01_23_45_67\" , 16 ); // x=0x01234567 bint_to_bytes ( & x , b , 4 , BINT_BIG_ENDIAN ); dump_data ( b , 4 ); // 01 23 45 67 bint_to_bytes ( & x , b , 6 , BINT_BIG_ENDIAN ); dump_data ( b , 6 ); // 00 00 01 23 45 67 Note \u50cf\u4e0a\u9762\u7684\u4ee3\u7801\u90a3\u6837\uff0c\u5f53\u5b57\u8282\u4e32\u957f\u5ea6\u8d85\u8fc7\u8868\u793a\u5927\u6574\u6570 BINT \u6240\u9700\u8981\u7684\u5927\u5c0f\u65f6\uff0c\u4f1a\u9ed8\u8ba4\u88650\uff0c\u5efa\u8bae\u91c7\u7528 bint_bytes_len \u51fd\u6570\u83b7\u53d6\u5927\u6574\u6570\u6240\u9700\u8981\u7684\u5b57\u8282\u5927\u5c0f\uff0c\u5982\u4e0b\u6240\u793a Example int bsize = bint_bytes_len ( & x ); // 4 bint_to_bytes ( & x , b , bsize , BINT_BIG_ENDIAN ); dump_data ( b , bsize ); // 01 23 45 67","title":"1.3 \u5b57\u8282\u4e32\u8f6c\u5316"},{"location":"bint/#_2","text":"","title":"\u4e8c\u3001\u5927\u6574\u6570\u8fd0\u7b97"},{"location":"bint/#21","text":"\u5927\u6574\u6570\u52a0\u6cd5 int bint_add ( BINT * r , BINT * n1 , BINT * n2 ); \u5927\u6574\u6570\u51cf\u6cd5 int bint_sub ( BINT * r , BINT * n1 , BINT * n2 ); Example BINT x , y , z1 , z2 ; bint_from_str ( & x , \"1000\" , 10 ); // x=1000 bint_from_str ( & y , \"2000\" , 10 ); // y=2000 bint_add ( & z1 , & x , & y ); // z1=x+y bint_sub ( & z2 , & x , & y ); // z2=x-y // x+y=3000 // x-y=-1000 printf ( \"x+y=%s \\n \" , bint_fast_to_str ( & z1 , 10 )); printf ( \"x-y=%s \\n \" , bint_fast_to_str ( & z2 , 10 ));","title":"2.1 \u52a0\u51cf\u6cd5"},{"location":"bint/#22","text":"\u5927\u6574\u6570\u4e58\u6cd5 int bint_mul ( BINT * r , BINT * n1 , BINT * n2 ); \u5927\u6574\u6570\u4e8c\u6b21\u5e42 int bint_sqr ( BINT * r , BINT * n ); \u5927\u6574\u6570\u4e58\u6cd5 int bint_mul_u32 ( BINT * r , BINT * n1 , uint32_t n2 ); Example BINT x , z1 , z2 , z3 ; bint_from_str ( & x , \"1000\" , 10 ); // x=1000 bint_mul ( & z1 , & x , & x ); // z1=x*x bint_sqr ( & z2 , & x ); // z2=x^2 bint_mul_u32 ( & z3 , & x , 1000 ); // z3=x*1000 // x*x = 1000000 // x^2 = 1000000 // x*1000= 1000000 printf ( \"x*x=%s \\n \" , bint_fast_to_str ( & z1 , 10 )); printf ( \"x^2=%s \\n \" , bint_fast_to_str ( & z2 , 10 )); printf ( \"x*1000=%s \\n \" , bint_fast_to_str ( & z3 , 10 ));","title":"2.2 \u4e58\u6cd5"},{"location":"bint/#23","text":"\u5927\u6574\u6570\u9664\u6cd5 int bint_divmod ( BINT * q , BINT * r , BINT * n1 , BINT * n2 ); \u5927\u6574\u6570\u9664\u6cd5 int bint_divmod_u32 ( BINT * q , uint32_t * r , BINT * n1 , uint32_t n2 ); Example BINT x , y , z1 , z2 ; uint32_t rem ; bint_from_str ( & x , \"1001\" , 10 ); // x=1001 bint_from_str ( & y , \"50\" , 10 ); // y=50 bint_divmod ( & z1 , & z2 , & x , & y ); // x div y = 20, x mod y = 1 printf ( \"x div y=%s \\n \" , bint_fast_to_str ( & z1 , 10 )); printf ( \"x mod y=%s \\n \" , bint_fast_to_str ( & z2 , 10 )); // same bint_divmod ( & z1 , NULL , & x , & y ); // \u4e22\u5f03\u4f59\u6570 bint_divmod ( NULL , & z2 , & x , & y ); // \u4e22\u5f03\u5546 // also like bint_divmod_u32 ( & z1 , & rem , & x , 50 );","title":"2.3 \u9664\u6cd5"},{"location":"bint/#24","text":"\u5927\u6574\u6570\u6c42\u5e42 int bint_pow ( BINT * r , BINT * n , BINT * e , BINT * mod ); \u5927\u6574\u6570\u6c42\u5e42 int bint_pow_u32 ( BINT * r , BINT * n , uint32_t e , BINT * mod ); Example BINT x , mod , z1 , z2 ; bint_from_str ( & x , \"1001\" , 10 ); // x=1001 // x^3 bint_pow ( & z1 , & x , & BINT_THREE , NULL ); bint_pow_u32 ( & z2 , & x , 3 , NULL ); // z1=1003003001, z2=1003003001 printf ( \"z1=%s \\n \" , bint_fast_to_str ( & z1 , 10 )); printf ( \"z2=%s \\n \" , bint_fast_to_str ( & z2 , 10 )); bint_from_str ( & mod , \"1000\" , 10 ); // mod=1000 bint_pow_u32 ( & z1 , & x , 3 , & mod ); // x^3 mod 1000 // z1=1 printf ( \"z1=%s \\n \" , bint_fast_to_str ( & z1 , 10 ));","title":"2.4 \u5e42"},{"location":"bint/#25","text":"\u5927\u6574\u6570\u903b\u8f91\uff08\u7b97\u6570\uff09\u5de6\u79fb int bint_sll ( BINT * r , BINT * n , int bits ); \u5927\u6574\u6570\u7b97\u6570\u53f3\u79fb int bint_sra ( BINT * r , BINT * n , int bits ); Example BINT x , z ; bint_from_str ( & x , \"1110\" , 2 ); // x=0b1110 bint_sll ( & z , & x , 3 ); // z=0b1110000 printf ( \"z=%s \\n \" , bint_fast_to_str ( & z , 2 )); bint_sra ( & z , & x , 2 ); // z=11 printf ( \"z=%s \\n \" , bint_fast_to_str ( & z , 2 ));","title":"2.5 \u7b97\u6570\u79fb\u4f4d"},{"location":"bint/#_3","text":"","title":"\u4e09\u3001\u5927\u6574\u6570\u529f\u80fd\u51fd\u6570"},{"location":"bint/#31","text":"\u5927\u6574\u6570\u6bd4\u8f83 int bint_cmp ( BINT * n1 , BINT * n2 ); \u662f\u5426\u4e3a\u96f6 inline int bint_is_zero ( BINT * n ); \u662f\u5426\u4e3a\u8d1f inline int bint_is_neg ( BINT * n ); \u662f\u5426\u4e3a\u6b63 inline int bint_is_pos ( BINT * n ); \u662f\u5426\u662f\u5947\u6570 inline int bint_is_odd ( BINT * n );","title":"3.1 \u6bd4\u8f83\u51fd\u6570"},{"location":"bint/#32","text":"\u8bbe\u7f6e\u5927\u6574\u6570\u4e3a\u96f6 inline void bint_set_zero ( BINT * n ); \u5927\u6574\u6570\u62f7\u8d1d void bint_copy ( BINT * r , BINT * n ); \u5927\u6574\u6570\u53d6\u8d1f void bint_neg ( BINT * r , BINT * n ); \u5927\u6574\u6570\u53d6\u7edd\u5bf9\u503c void bint_abs ( BINT * r , BINT * n );","title":"3.2 \u8bbe\u7f6e/\u62f7\u8d1d\u51fd\u6570"},{"location":"bint/#33","text":"\u5927\u6574\u6570\u7684\u5b57\u8282\u6570 int bint_bytes_len ( BINT * n ); \u5927\u6574\u6570\u7684\u6bd4\u7279\u6570 int bint_bits_len ( BINT * n ); \u5927\u6574\u6570\u67d0\u4e00\u6bd4\u7279\u4f4d\u6570\u503c int bint_bits_at ( BINT * n , int index ); Example BINT x ; bint_from_str ( & x , \"11100\" , 2 ); // x=0b11100 int bits = bint_bits_len ( & x ); // bits=5 for ( int i = bits - 1 ; i >= 0 ; i -- ) { // 1 1 1 0 0 printf ( \"%d \" , bint_bits_at ( & x , i )); } puts ( \"\" );","title":"3.3 \u6742\u9879/\u8f85\u52a9\u51fd\u6570"},{"location":"cipher/","text":"\u5206\u7ec4\u5bc6\u7801Cipher \u4e00\u3001\u7c7b\u578b\u5b9a\u4e49 file: gmlib/types.h \u6bcf\u4e2a\u5206\u7ec4\u5bc6\u7801\u7b97\u6cd5\u90fd\u5b9e\u73b0\u4e0b\u8ff0\u51fd\u6570\u5e76\u5b9a\u4e49\u76f8\u5e94\u7684 CipherInfo \u7ed3\u6784\u53d8\u91cf\uff0c\u7528\u4e8e\u5de5\u4f5c\u6a21\u5f0f\u7684\u8c03\u7528 \u7b97\u6cd5\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 typedef void ( * CipherInit )( uint8_t * key , void * ctx ); \u7b97\u6cd5\u52a0\u5bc6\u51fd\u6570 typedef void ( * CipherEncrypt )( uint8_t * out , uint8_t * in , void * ctx ); \u7b97\u6cd5\u89e3\u5bc6\u51fd\u6570 typedef void ( * CipherDecrypt )( uint8_t * out , uint8_t * in , void * ctx ); \u7b97\u6cd5\u4fe1\u606f(Info)\u7ed3\u6784\u4f53 typedef struct CipherInfo { CipherInit init ; ///< \u521d\u59cb\u5316\u7b97\u6cd5 CipherEncrypt encrypt ; ///< \u52a0\u5bc6\u7b97\u6cd5 CipherDecrypt decrypt ; ///< \u89e3\u5bc6\u7b97\u6cd5 } CipherInfo ; \u4e8c\u3001\u5bc6\u7801\u7b97\u6cd5 2.1 SM4 file: gmlib/cipher/sm4.h \u53c2\u8003\u8d44\u6599 GM/T 0002-2012 SM4\u5206\u7ec4\u5bc6\u7801\u7b97\u6cd5 \u90ce\u6b22, \u5f20\u857e, \u5434\u6587\u73b2. SM4\u7684\u5feb\u901f\u8f6f\u4ef6\u5b9e\u73b0\u6280\u672f \u7b97\u6cd5\u4fe1\u606f(Info)\u7ed3\u6784\u4f53 #define SM4_KEYLEN 16 #define SM4_BLOCK_SIZE 16 extern const CipherInfo SM4Info ; SM4\u7b97\u6cd5\u4e0a\u4e0b\u6587(Context)\u7ed3\u6784 typedef struct SM4_CTX { uint32_t rk [ 32 ]; // 32\u8f6e\u8f6e\u5bc6\u94a5 } SM4_CTX ; \u7b97\u6cd5\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 void sm4_init ( uint8_t * key , SM4_CTX * ctx ); \u7b97\u6cd5\u52a0\u5bc6\u51fd\u6570 void sm4_encrypt ( uint8_t * out , uint8_t * in , SM4_CTX * ctx ); \u7b97\u6cd5\u89e3\u5bc6\u51fd\u6570 void sm4_decrypt ( uint8_t * out , uint8_t * in , SM4_CTX * ctx ); Example static uint8_t sm4_key [ SM4_KEYLEN ] = { 0x01 , 0x23 , 0x45 , 0x67 , 0x89 , 0xab , 0xcd , 0xef , 0xfe , 0xdc , 0xba , 0x98 , 0x76 , 0x54 , 0x32 , 0x10 , }; static uint8_t sm4_pt [ SM4_BLOCK_SIZE ] = { 0x00 , 0x11 , 0x22 , 0x33 , 0x44 , 0x55 , 0x66 , 0x77 , 0x88 , 0x99 , 0xaa , 0xbb , 0xcc , 0xdd , 0xee , 0xff , }; // 128\u6bd4\u7279\u5bc6\u6587\u8f93\u51fa uint8_t out [ SM4_BLOCK_SIZE ]; SM4_CTX sm4key ; sm4_init ( sm4_key , & sm4key ); sm4_encrypt ( out , sm4_pt , & sm4key ); // 09 32 5c 48 53 83 2d cb 93 37 a5 98 4f 67 1b 9a dump_data ( out , SM4_BLOCK_SIZE ); 2.2 AES file: gmlib/cipher/aes.h \u53c2\u8003\u8d44\u6599 FIPS 197 Advanced Encryption Standard (AES) AES \u67e5\u8868\u4f18\u5316 \u7b97\u6cd5\u4fe1\u606f(Info)\u7ed3\u6784\u4f53 #define AES128_KEYLEN 16 #define AES192_KEYLEN 24 #define AES256_KEYLEN 32 #define AES_BLOCK_SIZE 16 extern const CipherInfo AES128Info ; extern const CipherInfo AES192Info ; extern const CipherInfo AES256Info ; AES\u7b97\u6cd5\u4e0a\u4e0b\u6587(Context)\u7ed3\u6784 typedef struct AES_CTX { uint32_t ek [ 4 * 15 ]; // \u52a0\u5bc6\u8f6e\u5bc6\u94a5 uint32_t dk [ 4 * 15 ]; // \u89e3\u5bc6\u8f6e\u5bc6\u94a5 int nr ; // \u52a0\u5bc6\u8f6e\u6570 } AES_CTX ; \u7b97\u6cd5\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 void aes_init ( uint8_t * key , int kbits , AES_CTX * ctx ); /// @brief AES128 \u521d\u59cb\u5316 void aes128_init ( uint8_t * key , AES_CTX * ctx ); /// @brief AES192 \u521d\u59cb\u5316 void aes192_init ( uint8_t * key , AES_CTX * ctx ); /// @brief AES256 \u521d\u59cb\u5316 void aes256_init ( uint8_t * key , AES_CTX * ctx ); \u7b97\u6cd5\u52a0\u5bc6\u51fd\u6570 void aes_encrypt ( uint8_t * out , uint8_t * in , AES_CTX * ctx ); \u7b97\u6cd5\u89e3\u5bc6\u51fd\u6570 void aes_decrypt ( uint8_t * out , uint8_t * in , AES_CTX * ctx ); \u4e09\u3001\u5de5\u4f5c\u6a21\u5f0f file: gmlib/cipher/mode.h \u53c2\u8003\u8d44\u6599 SP 800-38A Recommendation for Block Cipher Modes of Operation: Methods and Techniques SP 800-38D Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC D. McGrew and J. Viega. The Galois/Counter Mode of Operation (GCM) Note \u8be5\u7248\u672c\u5b9a\u4e49\u7684\u5de5\u4f5c\u6a21\u5f0f\u4ec5\u652f\u6301\u5bc6\u7801\u5206\u7ec4\u957f\u5ea6 BLOCK_SIZE \u4e3a16\u5b57\u8282(128\u6bd4\u7279)\u7684\u5206\u7ec4\u5bc6\u7801\u7b97\u6cd5 3.1 ECB\u6a21\u5f0f \u5de5\u4f5c\u6a21\u5f0f\u4e0a\u4e0b\u6587(Context) typedef struct ECB_CTX { uint8_t buffer [ BLOCK_SIZE ]; // \u7f13\u51b2\u533a int bsize ; // \u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f const CipherInfo * cipher ; // \u7b97\u6cd5\u53c2\u6570 void * cctx ; // \u7b97\u6cd5\u4e0a\u4e0b\u6587 } ECB_CTX ; \u6a21\u5f0f\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 void ecb_init ( uint8_t * key , ///< [in] \u7528\u6237\u5bc6\u94a5 const CipherInfo * cipher , ///< [in] \u7b97\u6cd5 void * cctx , ///< [inout] \u7b97\u6cd5\u4e0a\u4e0b\u6587 ECB_CTX * mctx ); \u6a21\u5f0f\u52a0\u5bc6\u51fd\u6570 void ecb_encrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 ECB_CTX * mctx ); void ecb_encrypt_final ( uint8_t * out , int * outl , ECB_CTX * mctx ); Note \u6267\u884c init \u51fd\u6570\u540e\uff0c\u591a\u6b21 update \u8f93\u5165\u6570\u636e\uff0c\u6700\u540e final \u5904\u7406\u586b\u5145 \u6a21\u5f0f\u89e3\u5bc6\u51fd\u6570 void ecb_decrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 ECB_CTX * mctx ); int ecb_decrypt_final ( uint8_t * out , int * outl , ECB_CTX * mctx ); Example #include <gmlib/cipher/mode.h> #include <gmlib/cipher/sm4.h> #include <gmlib/err.h> #include <gmlib/utils.h> static uint8_t sm4_key [ SM4_KEYLEN ] = { 0x01 , 0x23 , 0x45 , 0x67 , 0x89 , 0xab , 0xcd , 0xef , 0xfe , 0xdc , 0xba , 0x98 , 0x76 , 0x54 , 0x32 , 0x10 , }; static uint8_t sm4_pt [ SM4_BLOCK_SIZE ] = { 0x00 , 0x11 , 0x22 , 0x33 , 0x44 , 0x55 , 0x66 , 0x77 , 0x88 , 0x99 , 0xaa , 0xbb , 0xcc , 0xdd , 0xee , 0xff , }; static uint8_t out [ SM4_BLOCK_SIZE * 2 ]; int main () { SM4_CTX sm4key ; ECB_CTX ctx ; uint8_t * outptr = out ; int outl ; ecb_init ( sm4_key , & SM4Info , & sm4key , & ctx ); ecb_encrypt_update ( outptr , & outl , sm4_pt , sizeof ( sm4_pt ), & ctx ); outptr += outl ; ecb_encrypt_final ( outptr , & outl , & ctx ); outptr += outl ; // 09 32 5c 48 53 83 2d cb 93 37 a5 98 4f 67 1b 9a // 00 2a 8a 4e fa 86 3c ca d0 24 ac 03 00 bb 40 d2 dump_data ( out , ( int )( outptr - out )); return 0 ; } 3.2 CBC\u6a21\u5f0f \u5de5\u4f5c\u6a21\u5f0f\u4e0a\u4e0b\u6587(Context) typedef struct CBC_CTX { uint8_t iv [ BLOCK_SIZE ]; // \u521d\u59cb\u5411\u91cf uint8_t buffer [ BLOCK_SIZE ]; // \u7f13\u51b2\u533a int bsize ; // \u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f const CipherInfo * cipher ; // \u7b97\u6cd5\u53c2\u6570 void * cctx ; // \u7b97\u6cd5\u4e0a\u4e0b\u6587 } CBC_CTX ; \u6a21\u5f0f\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 void cbc_init ( uint8_t * key , ///< [in] \u7528\u6237\u5bc6\u94a5 uint8_t * iv , ///< [in] \u521d\u59cb\u5411\u91cf const CipherInfo * cipher , ///< [in] \u7b97\u6cd5 void * cctx , ///< [inout] \u7b97\u6cd5\u4e0a\u4e0b\u6587 CBC_CTX * mctx ); \u6a21\u5f0f\u52a0\u5bc6\u51fd\u6570 void cbc_encrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 CBC_CTX * mctx ); void cbc_encrypt_final ( uint8_t * out , int * outl , CBC_CTX * mctx ); \u6a21\u5f0f\u89e3\u5bc6\u51fd\u6570 void cbc_decrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 CBC_CTX * mctx ); int cbc_decrypt_final ( uint8_t * out , int * outl , CBC_CTX * mctx ); 3.3 GCM\u6a21\u5f0f \u5de5\u4f5c\u6a21\u5f0f\u4e0a\u4e0b\u6587(Context) Note GCM\u6a21\u5f0f\u4e0a\u4e0b\u6587 GCM_CTX \u7531GHash\u4e0a\u4e0b\u6587 GHash_CTX \u548cGCTR\u4e0a\u4e0b\u6587 GCTR_CTX \u5171\u540c\u6784\u6210\u3002 GHashTable \u662fGHash\u64cd\u4f5c\u7684\u67e5\u627e\u8868\uff0c\u5728GCM\u7684 init \u51fd\u6570\u4e2d\u53ef\u9009\u62e9\u4f20\u5165\u5bf9\u5e94\u6307\u9488\u6216\u662f NULL \uff0c\u4f20\u5165\u6307\u9488\u5219\u91c7\u7528\u67e5\u8868\u4f18\u5316\uff0c\u5426\u5219\u91c7\u7528\u666e\u901a\u5b9e\u73b0 // GHashTable \u5c06\u5360\u7528\u5de8\u5927\u5b58\u50a8\u7a7a\u95f4 typedef uint64_t GHashTable [ 256 ][ 2 ]; typedef struct GHash_CTX { uint8_t buffer [ BLOCK_SIZE ]; // \u7f13\u51b2\u533a int bsize ; // \u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f uint8_t X [ BLOCK_SIZE ]; // GHash\u5f53\u524d\u72b6\u6001X uint8_t H [ BLOCK_SIZE ]; // \u53c2\u6570H GHashTable * ht ; // \u67e5\u627e\u8868\u6307\u9488 } GHash_CTX ; typedef struct GCTR_CTX { uint8_t j0 [ BLOCK_SIZE ]; // \u521d\u59cb\u5411\u91cf uint8_t j [ BLOCK_SIZE ]; // \u521d\u59cb\u5411\u91cf uint8_t buffer [ BLOCK_SIZE ]; // \u7f13\u51b2\u533a int bsize ; // \u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f const CipherInfo * cipher ; // \u7b97\u6cd5\u53c2\u6570 void * cctx ; // \u7b97\u6cd5\u4e0a\u4e0b\u6587 } GCTR_CTX ; typedef struct GCM_CTX { GHash_CTX hctx ; // GHash\u4e0a\u4e0b\u6587 GCTR_CTX gctx ; // GCTR\u4e0a\u4e0b\u6587 int alen ; // AAD\u957f\u5ea6 int clen ; // \u5bc6\u6587\u957f\u5ea6 } GCM_CTX ; Note GCM\u6a21\u5f0f\u7684\u5927\u81f4\u6d41\u7a0b\u4e3a\uff1a\u8c03\u7528 init \u51fd\u6570\u521d\u59cb\u5316\uff0c\u8c03\u7528 update_aad \u51fd\u6570\u4f20\u5165AAD\u6570\u636e\uff0c\u63a5\u7740 update \u548c final \u8fdb\u884c\u52a0\u89e3\u5bc6 \u6a21\u5f0f\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 void gcm_init ( uint8_t * key , ///< [in] \u7528\u6237\u5bc6\u94a5 uint8_t * iv , ///< [in] \u521d\u59cb\u5411\u91cf int ivlen , ///< [in] \u521d\u59cb\u5411\u91cf\u957f\u5ea6 GHashTable * ht , ///< [inout] GHash\u67e5\u627e\u8868(\u53ef\u4e3aNULL) const CipherInfo * cipher , ///< [in] \u7b97\u6cd5 void * cctx , ///< [inout] \u7b97\u6cd5\u4e0a\u4e0b\u6587 GCM_CTX * mctx ); GCM\u8f93\u5165AAD(additional authenticated data) void gcm_update_aad ( uint8_t * aad , int alen , GCM_CTX * mctx ); \u6a21\u5f0f\u52a0\u5bc6\u51fd\u6570 void gcm_encrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 GCM_CTX * mctx ); void gcm_encrypt_final ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * tag , ///< [out] tag int tlen , ///< [in] tag\u957f\u5ea6 GCM_CTX * mctx ); \u6a21\u5f0f\u89e3\u5bc6\u51fd\u6570 void gcm_decrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 GCM_CTX * mctx ); int gcm_decrypt_final ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * tag , ///< [in] tag int tlen , ///< [in] tag\u957f\u5ea6 GCM_CTX * mctx );","title":"\u5206\u7ec4\u5bc6\u7801"},{"location":"cipher/#cipher","text":"","title":"\u5206\u7ec4\u5bc6\u7801Cipher"},{"location":"cipher/#_1","text":"file: gmlib/types.h \u6bcf\u4e2a\u5206\u7ec4\u5bc6\u7801\u7b97\u6cd5\u90fd\u5b9e\u73b0\u4e0b\u8ff0\u51fd\u6570\u5e76\u5b9a\u4e49\u76f8\u5e94\u7684 CipherInfo \u7ed3\u6784\u53d8\u91cf\uff0c\u7528\u4e8e\u5de5\u4f5c\u6a21\u5f0f\u7684\u8c03\u7528 \u7b97\u6cd5\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 typedef void ( * CipherInit )( uint8_t * key , void * ctx ); \u7b97\u6cd5\u52a0\u5bc6\u51fd\u6570 typedef void ( * CipherEncrypt )( uint8_t * out , uint8_t * in , void * ctx ); \u7b97\u6cd5\u89e3\u5bc6\u51fd\u6570 typedef void ( * CipherDecrypt )( uint8_t * out , uint8_t * in , void * ctx ); \u7b97\u6cd5\u4fe1\u606f(Info)\u7ed3\u6784\u4f53 typedef struct CipherInfo { CipherInit init ; ///< \u521d\u59cb\u5316\u7b97\u6cd5 CipherEncrypt encrypt ; ///< \u52a0\u5bc6\u7b97\u6cd5 CipherDecrypt decrypt ; ///< \u89e3\u5bc6\u7b97\u6cd5 } CipherInfo ;","title":"\u4e00\u3001\u7c7b\u578b\u5b9a\u4e49"},{"location":"cipher/#_2","text":"","title":"\u4e8c\u3001\u5bc6\u7801\u7b97\u6cd5"},{"location":"cipher/#21-sm4","text":"file: gmlib/cipher/sm4.h \u53c2\u8003\u8d44\u6599 GM/T 0002-2012 SM4\u5206\u7ec4\u5bc6\u7801\u7b97\u6cd5 \u90ce\u6b22, \u5f20\u857e, \u5434\u6587\u73b2. SM4\u7684\u5feb\u901f\u8f6f\u4ef6\u5b9e\u73b0\u6280\u672f \u7b97\u6cd5\u4fe1\u606f(Info)\u7ed3\u6784\u4f53 #define SM4_KEYLEN 16 #define SM4_BLOCK_SIZE 16 extern const CipherInfo SM4Info ; SM4\u7b97\u6cd5\u4e0a\u4e0b\u6587(Context)\u7ed3\u6784 typedef struct SM4_CTX { uint32_t rk [ 32 ]; // 32\u8f6e\u8f6e\u5bc6\u94a5 } SM4_CTX ; \u7b97\u6cd5\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 void sm4_init ( uint8_t * key , SM4_CTX * ctx ); \u7b97\u6cd5\u52a0\u5bc6\u51fd\u6570 void sm4_encrypt ( uint8_t * out , uint8_t * in , SM4_CTX * ctx ); \u7b97\u6cd5\u89e3\u5bc6\u51fd\u6570 void sm4_decrypt ( uint8_t * out , uint8_t * in , SM4_CTX * ctx ); Example static uint8_t sm4_key [ SM4_KEYLEN ] = { 0x01 , 0x23 , 0x45 , 0x67 , 0x89 , 0xab , 0xcd , 0xef , 0xfe , 0xdc , 0xba , 0x98 , 0x76 , 0x54 , 0x32 , 0x10 , }; static uint8_t sm4_pt [ SM4_BLOCK_SIZE ] = { 0x00 , 0x11 , 0x22 , 0x33 , 0x44 , 0x55 , 0x66 , 0x77 , 0x88 , 0x99 , 0xaa , 0xbb , 0xcc , 0xdd , 0xee , 0xff , }; // 128\u6bd4\u7279\u5bc6\u6587\u8f93\u51fa uint8_t out [ SM4_BLOCK_SIZE ]; SM4_CTX sm4key ; sm4_init ( sm4_key , & sm4key ); sm4_encrypt ( out , sm4_pt , & sm4key ); // 09 32 5c 48 53 83 2d cb 93 37 a5 98 4f 67 1b 9a dump_data ( out , SM4_BLOCK_SIZE );","title":"2.1 SM4"},{"location":"cipher/#22-aes","text":"file: gmlib/cipher/aes.h \u53c2\u8003\u8d44\u6599 FIPS 197 Advanced Encryption Standard (AES) AES \u67e5\u8868\u4f18\u5316 \u7b97\u6cd5\u4fe1\u606f(Info)\u7ed3\u6784\u4f53 #define AES128_KEYLEN 16 #define AES192_KEYLEN 24 #define AES256_KEYLEN 32 #define AES_BLOCK_SIZE 16 extern const CipherInfo AES128Info ; extern const CipherInfo AES192Info ; extern const CipherInfo AES256Info ; AES\u7b97\u6cd5\u4e0a\u4e0b\u6587(Context)\u7ed3\u6784 typedef struct AES_CTX { uint32_t ek [ 4 * 15 ]; // \u52a0\u5bc6\u8f6e\u5bc6\u94a5 uint32_t dk [ 4 * 15 ]; // \u89e3\u5bc6\u8f6e\u5bc6\u94a5 int nr ; // \u52a0\u5bc6\u8f6e\u6570 } AES_CTX ; \u7b97\u6cd5\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 void aes_init ( uint8_t * key , int kbits , AES_CTX * ctx ); /// @brief AES128 \u521d\u59cb\u5316 void aes128_init ( uint8_t * key , AES_CTX * ctx ); /// @brief AES192 \u521d\u59cb\u5316 void aes192_init ( uint8_t * key , AES_CTX * ctx ); /// @brief AES256 \u521d\u59cb\u5316 void aes256_init ( uint8_t * key , AES_CTX * ctx ); \u7b97\u6cd5\u52a0\u5bc6\u51fd\u6570 void aes_encrypt ( uint8_t * out , uint8_t * in , AES_CTX * ctx ); \u7b97\u6cd5\u89e3\u5bc6\u51fd\u6570 void aes_decrypt ( uint8_t * out , uint8_t * in , AES_CTX * ctx );","title":"2.2 AES"},{"location":"cipher/#_3","text":"file: gmlib/cipher/mode.h \u53c2\u8003\u8d44\u6599 SP 800-38A Recommendation for Block Cipher Modes of Operation: Methods and Techniques SP 800-38D Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC D. McGrew and J. Viega. The Galois/Counter Mode of Operation (GCM) Note \u8be5\u7248\u672c\u5b9a\u4e49\u7684\u5de5\u4f5c\u6a21\u5f0f\u4ec5\u652f\u6301\u5bc6\u7801\u5206\u7ec4\u957f\u5ea6 BLOCK_SIZE \u4e3a16\u5b57\u8282(128\u6bd4\u7279)\u7684\u5206\u7ec4\u5bc6\u7801\u7b97\u6cd5","title":"\u4e09\u3001\u5de5\u4f5c\u6a21\u5f0f"},{"location":"cipher/#31-ecb","text":"\u5de5\u4f5c\u6a21\u5f0f\u4e0a\u4e0b\u6587(Context) typedef struct ECB_CTX { uint8_t buffer [ BLOCK_SIZE ]; // \u7f13\u51b2\u533a int bsize ; // \u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f const CipherInfo * cipher ; // \u7b97\u6cd5\u53c2\u6570 void * cctx ; // \u7b97\u6cd5\u4e0a\u4e0b\u6587 } ECB_CTX ; \u6a21\u5f0f\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 void ecb_init ( uint8_t * key , ///< [in] \u7528\u6237\u5bc6\u94a5 const CipherInfo * cipher , ///< [in] \u7b97\u6cd5 void * cctx , ///< [inout] \u7b97\u6cd5\u4e0a\u4e0b\u6587 ECB_CTX * mctx ); \u6a21\u5f0f\u52a0\u5bc6\u51fd\u6570 void ecb_encrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 ECB_CTX * mctx ); void ecb_encrypt_final ( uint8_t * out , int * outl , ECB_CTX * mctx ); Note \u6267\u884c init \u51fd\u6570\u540e\uff0c\u591a\u6b21 update \u8f93\u5165\u6570\u636e\uff0c\u6700\u540e final \u5904\u7406\u586b\u5145 \u6a21\u5f0f\u89e3\u5bc6\u51fd\u6570 void ecb_decrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 ECB_CTX * mctx ); int ecb_decrypt_final ( uint8_t * out , int * outl , ECB_CTX * mctx ); Example #include <gmlib/cipher/mode.h> #include <gmlib/cipher/sm4.h> #include <gmlib/err.h> #include <gmlib/utils.h> static uint8_t sm4_key [ SM4_KEYLEN ] = { 0x01 , 0x23 , 0x45 , 0x67 , 0x89 , 0xab , 0xcd , 0xef , 0xfe , 0xdc , 0xba , 0x98 , 0x76 , 0x54 , 0x32 , 0x10 , }; static uint8_t sm4_pt [ SM4_BLOCK_SIZE ] = { 0x00 , 0x11 , 0x22 , 0x33 , 0x44 , 0x55 , 0x66 , 0x77 , 0x88 , 0x99 , 0xaa , 0xbb , 0xcc , 0xdd , 0xee , 0xff , }; static uint8_t out [ SM4_BLOCK_SIZE * 2 ]; int main () { SM4_CTX sm4key ; ECB_CTX ctx ; uint8_t * outptr = out ; int outl ; ecb_init ( sm4_key , & SM4Info , & sm4key , & ctx ); ecb_encrypt_update ( outptr , & outl , sm4_pt , sizeof ( sm4_pt ), & ctx ); outptr += outl ; ecb_encrypt_final ( outptr , & outl , & ctx ); outptr += outl ; // 09 32 5c 48 53 83 2d cb 93 37 a5 98 4f 67 1b 9a // 00 2a 8a 4e fa 86 3c ca d0 24 ac 03 00 bb 40 d2 dump_data ( out , ( int )( outptr - out )); return 0 ; }","title":"3.1 ECB\u6a21\u5f0f"},{"location":"cipher/#32-cbc","text":"\u5de5\u4f5c\u6a21\u5f0f\u4e0a\u4e0b\u6587(Context) typedef struct CBC_CTX { uint8_t iv [ BLOCK_SIZE ]; // \u521d\u59cb\u5411\u91cf uint8_t buffer [ BLOCK_SIZE ]; // \u7f13\u51b2\u533a int bsize ; // \u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f const CipherInfo * cipher ; // \u7b97\u6cd5\u53c2\u6570 void * cctx ; // \u7b97\u6cd5\u4e0a\u4e0b\u6587 } CBC_CTX ; \u6a21\u5f0f\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 void cbc_init ( uint8_t * key , ///< [in] \u7528\u6237\u5bc6\u94a5 uint8_t * iv , ///< [in] \u521d\u59cb\u5411\u91cf const CipherInfo * cipher , ///< [in] \u7b97\u6cd5 void * cctx , ///< [inout] \u7b97\u6cd5\u4e0a\u4e0b\u6587 CBC_CTX * mctx ); \u6a21\u5f0f\u52a0\u5bc6\u51fd\u6570 void cbc_encrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 CBC_CTX * mctx ); void cbc_encrypt_final ( uint8_t * out , int * outl , CBC_CTX * mctx ); \u6a21\u5f0f\u89e3\u5bc6\u51fd\u6570 void cbc_decrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 CBC_CTX * mctx ); int cbc_decrypt_final ( uint8_t * out , int * outl , CBC_CTX * mctx );","title":"3.2 CBC\u6a21\u5f0f"},{"location":"cipher/#33-gcm","text":"\u5de5\u4f5c\u6a21\u5f0f\u4e0a\u4e0b\u6587(Context) Note GCM\u6a21\u5f0f\u4e0a\u4e0b\u6587 GCM_CTX \u7531GHash\u4e0a\u4e0b\u6587 GHash_CTX \u548cGCTR\u4e0a\u4e0b\u6587 GCTR_CTX \u5171\u540c\u6784\u6210\u3002 GHashTable \u662fGHash\u64cd\u4f5c\u7684\u67e5\u627e\u8868\uff0c\u5728GCM\u7684 init \u51fd\u6570\u4e2d\u53ef\u9009\u62e9\u4f20\u5165\u5bf9\u5e94\u6307\u9488\u6216\u662f NULL \uff0c\u4f20\u5165\u6307\u9488\u5219\u91c7\u7528\u67e5\u8868\u4f18\u5316\uff0c\u5426\u5219\u91c7\u7528\u666e\u901a\u5b9e\u73b0 // GHashTable \u5c06\u5360\u7528\u5de8\u5927\u5b58\u50a8\u7a7a\u95f4 typedef uint64_t GHashTable [ 256 ][ 2 ]; typedef struct GHash_CTX { uint8_t buffer [ BLOCK_SIZE ]; // \u7f13\u51b2\u533a int bsize ; // \u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f uint8_t X [ BLOCK_SIZE ]; // GHash\u5f53\u524d\u72b6\u6001X uint8_t H [ BLOCK_SIZE ]; // \u53c2\u6570H GHashTable * ht ; // \u67e5\u627e\u8868\u6307\u9488 } GHash_CTX ; typedef struct GCTR_CTX { uint8_t j0 [ BLOCK_SIZE ]; // \u521d\u59cb\u5411\u91cf uint8_t j [ BLOCK_SIZE ]; // \u521d\u59cb\u5411\u91cf uint8_t buffer [ BLOCK_SIZE ]; // \u7f13\u51b2\u533a int bsize ; // \u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f const CipherInfo * cipher ; // \u7b97\u6cd5\u53c2\u6570 void * cctx ; // \u7b97\u6cd5\u4e0a\u4e0b\u6587 } GCTR_CTX ; typedef struct GCM_CTX { GHash_CTX hctx ; // GHash\u4e0a\u4e0b\u6587 GCTR_CTX gctx ; // GCTR\u4e0a\u4e0b\u6587 int alen ; // AAD\u957f\u5ea6 int clen ; // \u5bc6\u6587\u957f\u5ea6 } GCM_CTX ; Note GCM\u6a21\u5f0f\u7684\u5927\u81f4\u6d41\u7a0b\u4e3a\uff1a\u8c03\u7528 init \u51fd\u6570\u521d\u59cb\u5316\uff0c\u8c03\u7528 update_aad \u51fd\u6570\u4f20\u5165AAD\u6570\u636e\uff0c\u63a5\u7740 update \u548c final \u8fdb\u884c\u52a0\u89e3\u5bc6 \u6a21\u5f0f\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316\u51fd\u6570 void gcm_init ( uint8_t * key , ///< [in] \u7528\u6237\u5bc6\u94a5 uint8_t * iv , ///< [in] \u521d\u59cb\u5411\u91cf int ivlen , ///< [in] \u521d\u59cb\u5411\u91cf\u957f\u5ea6 GHashTable * ht , ///< [inout] GHash\u67e5\u627e\u8868(\u53ef\u4e3aNULL) const CipherInfo * cipher , ///< [in] \u7b97\u6cd5 void * cctx , ///< [inout] \u7b97\u6cd5\u4e0a\u4e0b\u6587 GCM_CTX * mctx ); GCM\u8f93\u5165AAD(additional authenticated data) void gcm_update_aad ( uint8_t * aad , int alen , GCM_CTX * mctx ); \u6a21\u5f0f\u52a0\u5bc6\u51fd\u6570 void gcm_encrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 GCM_CTX * mctx ); void gcm_encrypt_final ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * tag , ///< [out] tag int tlen , ///< [in] tag\u957f\u5ea6 GCM_CTX * mctx ); \u6a21\u5f0f\u89e3\u5bc6\u51fd\u6570 void gcm_decrypt_update ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 GCM_CTX * mctx ); int gcm_decrypt_final ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * tag , ///< [in] tag int tlen , ///< [in] tag\u957f\u5ea6 GCM_CTX * mctx );","title":"3.3 GCM\u6a21\u5f0f"},{"location":"ec/","text":"\u692d\u5706\u66f2\u7ebf\u8fd0\u7b97 file: gmlib/ec.h \u4e00\u3001\u7ed3\u6784\u5b9a\u4e49 \u692d\u5706\u66f2\u7ebf\u70b9 typedef struct ECPoint { BINT x , y ; // \u5750\u6807 int infinity ; // 1(\u65e0\u7a77\u8fdc\u70b9), 0(\u975e\u65e0\u7a77\u8fdc) } ECPoint ; \u692d\u5706\u66f2\u7ebf\u57df typedef struct EC_CTX { BINT a , b ; // y^2 = x^3+ax+b BINT p ; // \u7d20\u6570 ECPoint G ; // \u751f\u6210\u5143 BINT n ; // \u9636 } EC_CTX ; \u692d\u5706\u66f2\u7ebf\u57df\u4e0a\u4e0b\u6587(Context)\u5e38\u91cf extern EC_CTX EC_Fp192_CTX ; extern EC_CTX EC_Fp256_CTX ; \u4e8c\u3001\u6784\u9020\u51fd\u6570 2.1 \u6784\u9020\u51fd\u6570 \u692d\u5706\u66f2\u7ebf\u57df\u4e0a\u4e0b\u6587\u6784\u9020 void ec_ctx_construct ( EC_CTX * r , ///< [out] \u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587 BINT * a , ///< [in] \u53c2\u6570a BINT * b , ///< [in] \u53c2\u6570b BINT * p , ///< [in] \u7d20\u57dfp ECPoint * G , ///< [in] \u66f2\u7ebf\u751f\u6210\u5143G BINT * n ///< [in] \u751f\u6210\u5143\u7684\u9636n ); \u692d\u5706\u66f2\u7ebf\u70b9\u6784\u9020 void ec_construct ( ECPoint * r , BINT * x , BINT * y ); 2.2 \u62f7\u8d1d\u51fd\u6570 \u692d\u5706\u66f2\u7ebf\u57df\u4e0a\u4e0b\u6587\u62f7\u8d1d void ec_ctx_copy ( EC_CTX * r , EC_CTX * ctx ); \u692d\u5706\u66f2\u7ebf\u70b9\u62f7\u8d1d void ec_copy ( ECPoint * r , ECPoint * n ); 2.3 \u5b57\u8282\u4e32\u8f6c\u6362 // \u975e\u538b\u7f29\u5f62\u5f0f #define EC_PC_NO_ZIP 0x04 \u692d\u5706\u66f2\u7ebf\u70b9\u8f6c\u5b57\u8282\u4e32 int ec_to_bytes ( ECPoint * n , int PC , uint8_t * b , int * bsize , EC_CTX * ec_ctx ); \u5b57\u8282\u4e32\u8bfb\u5165\u692d\u5706\u66f2\u7ebf\u70b9 int ec_from_bytes ( ECPoint * n , uint8_t * b , int * read_size , EC_CTX * ec_ctx ); \u4e09\u3001\u692d\u5706\u66f2\u7ebf\u7b97\u6570 \u692d\u5706\u66f2\u7ebf\u70b9\u52a0 int ec_add ( ECPoint * r , ECPoint * n1 , ECPoint * n2 , EC_CTX * ec_ctx ); \u692d\u5706\u66f2\u7ebf\u591a\u500d\u70b9 int ec_mul ( ECPoint * r , BINT * k , ECPoint * n , EC_CTX * ec_ctx ); \u56db\u3001\u692d\u5706\u66f2\u7ebf\u529f\u80fd\u51fd\u6570 \u692d\u5706\u66f2\u7ebf\u70b9\u5224\u7b49 int ec_equal ( ECPoint * n1 , ECPoint * n2 ); \u692d\u5706\u66f2\u7ebf\u70b9\u4e92\u9006\u5224\u65ad int ec_neg_equal ( ECPoint * n1 , ECPoint * n2 ); \u692d\u5706\u66f2\u7ebf\u662f\u5426\u662f\u65e0\u7a77\u8fdc\u70b9 int ec_is_infinity ( ECPoint * n ); \u692d\u5706\u66f2\u7ebf\u8bbe\u7f6e\u65e0\u7a77\u8fdc\u70b9 void ec_set_infinity ( ECPoint * n ); \u6821\u9a8c\u70b9\u662f\u5426\u5728\u692d\u5706\u66f2\u7ebf\u4e0a int ec_check ( ECPoint * n , int * status , EC_CTX * ec_ctx ); \u692d\u5706\u66f2\u7ebf\u70b9\u53d6\u8d1f int ec_neg ( ECPoint * r , ECPoint * n , EC_CTX * ec_ctx );","title":"\u692d\u5706\u66f2\u7ebf"},{"location":"ec/#_1","text":"file: gmlib/ec.h","title":"\u692d\u5706\u66f2\u7ebf\u8fd0\u7b97"},{"location":"ec/#_2","text":"\u692d\u5706\u66f2\u7ebf\u70b9 typedef struct ECPoint { BINT x , y ; // \u5750\u6807 int infinity ; // 1(\u65e0\u7a77\u8fdc\u70b9), 0(\u975e\u65e0\u7a77\u8fdc) } ECPoint ; \u692d\u5706\u66f2\u7ebf\u57df typedef struct EC_CTX { BINT a , b ; // y^2 = x^3+ax+b BINT p ; // \u7d20\u6570 ECPoint G ; // \u751f\u6210\u5143 BINT n ; // \u9636 } EC_CTX ; \u692d\u5706\u66f2\u7ebf\u57df\u4e0a\u4e0b\u6587(Context)\u5e38\u91cf extern EC_CTX EC_Fp192_CTX ; extern EC_CTX EC_Fp256_CTX ;","title":"\u4e00\u3001\u7ed3\u6784\u5b9a\u4e49"},{"location":"ec/#_3","text":"","title":"\u4e8c\u3001\u6784\u9020\u51fd\u6570"},{"location":"ec/#21","text":"\u692d\u5706\u66f2\u7ebf\u57df\u4e0a\u4e0b\u6587\u6784\u9020 void ec_ctx_construct ( EC_CTX * r , ///< [out] \u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587 BINT * a , ///< [in] \u53c2\u6570a BINT * b , ///< [in] \u53c2\u6570b BINT * p , ///< [in] \u7d20\u57dfp ECPoint * G , ///< [in] \u66f2\u7ebf\u751f\u6210\u5143G BINT * n ///< [in] \u751f\u6210\u5143\u7684\u9636n ); \u692d\u5706\u66f2\u7ebf\u70b9\u6784\u9020 void ec_construct ( ECPoint * r , BINT * x , BINT * y );","title":"2.1 \u6784\u9020\u51fd\u6570"},{"location":"ec/#22","text":"\u692d\u5706\u66f2\u7ebf\u57df\u4e0a\u4e0b\u6587\u62f7\u8d1d void ec_ctx_copy ( EC_CTX * r , EC_CTX * ctx ); \u692d\u5706\u66f2\u7ebf\u70b9\u62f7\u8d1d void ec_copy ( ECPoint * r , ECPoint * n );","title":"2.2 \u62f7\u8d1d\u51fd\u6570"},{"location":"ec/#23","text":"// \u975e\u538b\u7f29\u5f62\u5f0f #define EC_PC_NO_ZIP 0x04 \u692d\u5706\u66f2\u7ebf\u70b9\u8f6c\u5b57\u8282\u4e32 int ec_to_bytes ( ECPoint * n , int PC , uint8_t * b , int * bsize , EC_CTX * ec_ctx ); \u5b57\u8282\u4e32\u8bfb\u5165\u692d\u5706\u66f2\u7ebf\u70b9 int ec_from_bytes ( ECPoint * n , uint8_t * b , int * read_size , EC_CTX * ec_ctx );","title":"2.3 \u5b57\u8282\u4e32\u8f6c\u6362"},{"location":"ec/#_4","text":"\u692d\u5706\u66f2\u7ebf\u70b9\u52a0 int ec_add ( ECPoint * r , ECPoint * n1 , ECPoint * n2 , EC_CTX * ec_ctx ); \u692d\u5706\u66f2\u7ebf\u591a\u500d\u70b9 int ec_mul ( ECPoint * r , BINT * k , ECPoint * n , EC_CTX * ec_ctx );","title":"\u4e09\u3001\u692d\u5706\u66f2\u7ebf\u7b97\u6570"},{"location":"ec/#_5","text":"\u692d\u5706\u66f2\u7ebf\u70b9\u5224\u7b49 int ec_equal ( ECPoint * n1 , ECPoint * n2 ); \u692d\u5706\u66f2\u7ebf\u70b9\u4e92\u9006\u5224\u65ad int ec_neg_equal ( ECPoint * n1 , ECPoint * n2 ); \u692d\u5706\u66f2\u7ebf\u662f\u5426\u662f\u65e0\u7a77\u8fdc\u70b9 int ec_is_infinity ( ECPoint * n ); \u692d\u5706\u66f2\u7ebf\u8bbe\u7f6e\u65e0\u7a77\u8fdc\u70b9 void ec_set_infinity ( ECPoint * n ); \u6821\u9a8c\u70b9\u662f\u5426\u5728\u692d\u5706\u66f2\u7ebf\u4e0a int ec_check ( ECPoint * n , int * status , EC_CTX * ec_ctx ); \u692d\u5706\u66f2\u7ebf\u70b9\u53d6\u8d1f int ec_neg ( ECPoint * r , ECPoint * n , EC_CTX * ec_ctx );","title":"\u56db\u3001\u692d\u5706\u66f2\u7ebf\u529f\u80fd\u51fd\u6570"},{"location":"err/","text":"\u9519\u8bef\u5904\u7406 file: gmlib/err.h #define ERR_NOERROR 0 #define ERR_RUNTIME_ERROR 1 \u5b8f\u51fd\u6570 ERR_LOG \u63a5\u6536\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u4e0e\u53c2\u6570\uff0c\u5c06\u9519\u8bef\u4fe1\u606f\u8f93\u51fa\u81f3 stderr \u4e2d\uff0c\u8f93\u51fa\u7684\u9519\u8bef\u4fe1\u606f\u5305\u62ec\u6587\u4ef6\u540d\u3001\u4ee3\u7801\u4f4d\u7f6e\u4ee5\u53ca\u51fd\u6570\u540d\u79f0 #define ERR_LOG(_fmt, ...) \\ fprintf(stderr, \\ \"[Error] \"_fmt \\ \". File `%s`, line %d, in `%s`\\n\", \\ __VA_ARGS__, __FILE__, __LINE__, __FUNCTION__) \u8c03\u7528\u65b9\u5f0f\u4f8b\u5982 ERR_LOG(\"Err Happen\") \u6216\u662f ERR_LOG(\"Err Happen, get %d\", 2) Note ERR_LOG \u4ec5\u5728\u5b9a\u4e49\u4e86 GMLIB_DEBUG \u5b8f\u65f6\u624d\u4f1a\u6253\u5370\u9519\u8bef\u4fe1\u606f\uff0c\u5f53 GMLIB_DEBUG \u5b8f\u672a\u5b9a\u4e49\u65f6\u7b49\u4ef7\u4e8e\u7a7a\u8bed\u53e5 \u5b8f\u51fd\u6570 try_goto \u5fc5\u987b\u642d\u914d C \u8bed\u8a00\u7684\u6807\u7b7e error \u4f7f\u7528\uff0c\u4f7f\u7528 try_goto \u5b8f\u53ef\u4ee5\u4f7f\u5f97\u9519\u8bef\u5904\u7406\u66f4\u4e3a\u65b9\u4fbf\uff0c\u6e90\u4ee3\u7801\u4e2d\u5c06\u5927\u91cf\u91c7\u7528\u8fd9\u79cd\u8868\u8fbe\u65b9\u5f0f Example #include <gmlib/bint.h> #include <gmlib/err.h> int main () { BINT x ; // try_goto try_goto ( bint_from_str ( & x , \"a\" , 10 )); // same expression if ( bint_from_str ( & x , \"a\" , 10 ) != ERR_NOERROR ) { ERR_LOG ( \"Err Happen\" ); goto error ; } return 0 ; error : return -1 ; }","title":"\u9519\u8bef\u5904\u7406"},{"location":"err/#_1","text":"file: gmlib/err.h #define ERR_NOERROR 0 #define ERR_RUNTIME_ERROR 1 \u5b8f\u51fd\u6570 ERR_LOG \u63a5\u6536\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u4e0e\u53c2\u6570\uff0c\u5c06\u9519\u8bef\u4fe1\u606f\u8f93\u51fa\u81f3 stderr \u4e2d\uff0c\u8f93\u51fa\u7684\u9519\u8bef\u4fe1\u606f\u5305\u62ec\u6587\u4ef6\u540d\u3001\u4ee3\u7801\u4f4d\u7f6e\u4ee5\u53ca\u51fd\u6570\u540d\u79f0 #define ERR_LOG(_fmt, ...) \\ fprintf(stderr, \\ \"[Error] \"_fmt \\ \". File `%s`, line %d, in `%s`\\n\", \\ __VA_ARGS__, __FILE__, __LINE__, __FUNCTION__) \u8c03\u7528\u65b9\u5f0f\u4f8b\u5982 ERR_LOG(\"Err Happen\") \u6216\u662f ERR_LOG(\"Err Happen, get %d\", 2) Note ERR_LOG \u4ec5\u5728\u5b9a\u4e49\u4e86 GMLIB_DEBUG \u5b8f\u65f6\u624d\u4f1a\u6253\u5370\u9519\u8bef\u4fe1\u606f\uff0c\u5f53 GMLIB_DEBUG \u5b8f\u672a\u5b9a\u4e49\u65f6\u7b49\u4ef7\u4e8e\u7a7a\u8bed\u53e5 \u5b8f\u51fd\u6570 try_goto \u5fc5\u987b\u642d\u914d C \u8bed\u8a00\u7684\u6807\u7b7e error \u4f7f\u7528\uff0c\u4f7f\u7528 try_goto \u5b8f\u53ef\u4ee5\u4f7f\u5f97\u9519\u8bef\u5904\u7406\u66f4\u4e3a\u65b9\u4fbf\uff0c\u6e90\u4ee3\u7801\u4e2d\u5c06\u5927\u91cf\u91c7\u7528\u8fd9\u79cd\u8868\u8fbe\u65b9\u5f0f Example #include <gmlib/bint.h> #include <gmlib/err.h> int main () { BINT x ; // try_goto try_goto ( bint_from_str ( & x , \"a\" , 10 )); // same expression if ( bint_from_str ( & x , \"a\" , 10 ) != ERR_NOERROR ) { ERR_LOG ( \"Err Happen\" ); goto error ; } return 0 ; error : return -1 ; }","title":"\u9519\u8bef\u5904\u7406"},{"location":"hash/","text":"\u54c8\u5e0c\u7b97\u6cd5Hash \u4e00\u3001\u7c7b\u578b\u5b9a\u4e49 \u4e8c\u3001\u54c8\u5e0c\u7b97\u6cd5 2.1 SM3\u7b97\u6cd5 file: gmlib/hash/sm3.h \u53c2\u8003\u8d44\u6599 GM/T 0004-2012 SM3 \u5bc6\u7801\u6742\u51d1\u7b97\u6cd5 GmSSL(https://github.com/guanzhi/GmSSL) SM3\u7b97\u6cd5\u4e0a\u4e0b\u6587(Context) // SM3 \u6458\u8981\u5b57\u8282\u6570 #define SM3_DIGEST_SIZE (256 / 8) // SM3 \u538b\u7f29\u51fd\u6570\u5206\u7ec4\u6570 #define SM3_BLOCK_SIZE (512 / 8) typedef struct SM3_CTX { uint32_t state [ 8 ]; // SM3 \u72b6\u6001\u6570\u636e uint8_t buffer [ SM3_BLOCK_SIZE ]; // \u6d88\u606f buffer int bsize ; // buffer \u957f\u5ea6 uint64_t dbits ; // \u6d88\u606f\u6bd4\u7279\u957f\u5ea6 } SM3_CTX ; SM3\u4e0a\u4e0b\u6587\u521d\u59cb\u5316 void sm3_init ( SM3_CTX * ctx ); SM3\u54c8\u5e0c void sm3_update ( uint8_t * in , int inl , SM3_CTX * ctx ); void sm3_final ( uint8_t * out , SM3_CTX * ctx ); Example #include <gmlib/hash/sm3.h> #include <gmlib/utils.h> int main () { SM3_CTX sm3_ctx ; uint8_t msg [] = { 'a' , 'b' , 'c' }; // \u539f\u59cb\u6d88\u606f uint8_t digest [ SM3_DIGEST_SIZE ]; // \u6d88\u606f\u6458\u8981 // \u521d\u59cb\u5316 SM3 sm3_init ( & sm3_ctx ); // \u8f93\u5165\u6d88\u606f sm3_update ( msg , sizeof ( msg ), & sm3_ctx ); // \u7ed3\u675f SM3 \u5e76\u8f93\u51fa\u6458\u8981 digest sm3_final ( digest , & sm3_ctx ); dump_data ( digest , sizeof ( digest )); /* SM3 \u6458\u8981\u7ed3\u679c 66 c7 f0 f4 62 ee ed d9 d1 f2 d4 6b dc 10 e4 e2 41 67 c4 87 5c f2 f7 a2 29 7d a0 2b 8f 4b a8 e0 */ return 0 ; }","title":"\u54c8\u5e0c\u51fd\u6570"},{"location":"hash/#hash","text":"","title":"\u54c8\u5e0c\u7b97\u6cd5Hash"},{"location":"hash/#_1","text":"","title":"\u4e00\u3001\u7c7b\u578b\u5b9a\u4e49"},{"location":"hash/#_2","text":"","title":"\u4e8c\u3001\u54c8\u5e0c\u7b97\u6cd5"},{"location":"hash/#21-sm3","text":"file: gmlib/hash/sm3.h \u53c2\u8003\u8d44\u6599 GM/T 0004-2012 SM3 \u5bc6\u7801\u6742\u51d1\u7b97\u6cd5 GmSSL(https://github.com/guanzhi/GmSSL) SM3\u7b97\u6cd5\u4e0a\u4e0b\u6587(Context) // SM3 \u6458\u8981\u5b57\u8282\u6570 #define SM3_DIGEST_SIZE (256 / 8) // SM3 \u538b\u7f29\u51fd\u6570\u5206\u7ec4\u6570 #define SM3_BLOCK_SIZE (512 / 8) typedef struct SM3_CTX { uint32_t state [ 8 ]; // SM3 \u72b6\u6001\u6570\u636e uint8_t buffer [ SM3_BLOCK_SIZE ]; // \u6d88\u606f buffer int bsize ; // buffer \u957f\u5ea6 uint64_t dbits ; // \u6d88\u606f\u6bd4\u7279\u957f\u5ea6 } SM3_CTX ; SM3\u4e0a\u4e0b\u6587\u521d\u59cb\u5316 void sm3_init ( SM3_CTX * ctx ); SM3\u54c8\u5e0c void sm3_update ( uint8_t * in , int inl , SM3_CTX * ctx ); void sm3_final ( uint8_t * out , SM3_CTX * ctx ); Example #include <gmlib/hash/sm3.h> #include <gmlib/utils.h> int main () { SM3_CTX sm3_ctx ; uint8_t msg [] = { 'a' , 'b' , 'c' }; // \u539f\u59cb\u6d88\u606f uint8_t digest [ SM3_DIGEST_SIZE ]; // \u6d88\u606f\u6458\u8981 // \u521d\u59cb\u5316 SM3 sm3_init ( & sm3_ctx ); // \u8f93\u5165\u6d88\u606f sm3_update ( msg , sizeof ( msg ), & sm3_ctx ); // \u7ed3\u675f SM3 \u5e76\u8f93\u51fa\u6458\u8981 digest sm3_final ( digest , & sm3_ctx ); dump_data ( digest , sizeof ( digest )); /* SM3 \u6458\u8981\u7ed3\u679c 66 c7 f0 f4 62 ee ed d9 d1 f2 d4 6b dc 10 e4 e2 41 67 c4 87 5c f2 f7 a2 29 7d a0 2b 8f 4b a8 e0 */ return 0 ; }","title":"2.1 SM3\u7b97\u6cd5"},{"location":"license/","text":"LICENSE BSD 3-Clause License Copyright (c) 2022, kentle All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"\u5173\u4e8e"},{"location":"license/#license","text":"BSD 3-Clause License Copyright (c) 2022, kentle All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"LICENSE"},{"location":"math/","text":"\u6570\u5b66\u8fd0\u7b97 file: gmlib/math.h \u53c2\u8003\u8d44\u6599 openssl 3.0 \u5927\u6574\u6570 bn \u6a21\u5757 \u5bc6\u7801\u5b66\u5b9e\u9a8c\u6559\u7a0b. \u90ed\u534e\u3001\u5218\u5efa\u4f1f\u3001\u674e\u5927\u4f1f \u4e00\u3001\u4e00\u822c\u51fd\u6570 \u968f\u673a\u751f\u6210bits\u6bd4\u7279\u5927\u6574\u6570 int bint_rand_bits ( BINT * r , int bits ); \u968f\u673a\u751f\u6210[left, right)\u8303\u56f4\u5927\u6574\u6570 int bint_rand_range ( BINT * r , BINT * left , BINT * right ); \u968f\u673a\u751f\u6210 bits \u6bd4\u7279\u5927\u7d20\u6570 int bint_prime_bits ( BINT * r , int bits ); \u7d20\u6027\u5224\u65ad(\u65e0\u89c6\u7b26\u53f7\u4f4d) int bint_is_prime ( BINT * n , int * status ); Example BINT p ; int status = 0 ; bint_prime_bits ( & p , 256 ); // 256 \u6bd4\u7279\u7d20\u6570 bint_is_prime ( & p , & status ); // \u7d20\u6027\u68c0\u6d4b // is prime if ( status == 1 ) { puts ( \"is prime\" ); } else { puts ( \"not prime\" ); } \u6700\u5927\u516c\u7ea6\u6570 int bint_gcd ( BINT * gcd , BINT * n1 , BINT * n2 ); \u4e8c\u3001\u6709\u9650\u57df\u8fd0\u7b97 Note \u6709\u9650\u57df fp \u8fd0\u7b97\u8981\u6c42\u8f93\u5165\u7684 p \u4e3a\u7d20\u6570\uff0c\u4e14\u8f93\u51fa\u7ed3\u679c\u4e3a\u975e\u8d1f \u6709\u9650\u57df\u52a0\u6cd5 int fp_add ( BINT * r , BINT * n1 , BINT * n2 , BINT * p ); \u6709\u9650\u57df\u51cf\u6cd5 int fp_sub ( BINT * r , BINT * n1 , BINT * n2 , BINT * p ); \u6709\u9650\u57df\u4e58\u6cd5 int fp_mul ( BINT * r , BINT * n1 , BINT * n2 , BINT * p ); \u6709\u9650\u57df\u4e58\u6cd5 int fp_mul_u32 ( BINT * r , BINT * n1 , uint32_t n2 , BINT * p ); \u6709\u9650\u57df\u5e73\u65b9 int fp_sqr ( BINT * r , BINT * n , BINT * p ); \u6709\u9650\u57df\u6c42\u5e42 int fp_pow ( BINT * r , BINT * n , BINT * e , BINT * p ); \u6709\u9650\u57df\u6c42\u9006 int fp_inverse ( BINT * r , BINT * n , BINT * p ); \u6709\u9650\u57df\u53d6\u8d1f int fp_neg ( BINT * r , BINT * n , BINT * p );","title":"\u6570\u5b66\u51fd\u6570"},{"location":"math/#_1","text":"file: gmlib/math.h \u53c2\u8003\u8d44\u6599 openssl 3.0 \u5927\u6574\u6570 bn \u6a21\u5757 \u5bc6\u7801\u5b66\u5b9e\u9a8c\u6559\u7a0b. \u90ed\u534e\u3001\u5218\u5efa\u4f1f\u3001\u674e\u5927\u4f1f","title":"\u6570\u5b66\u8fd0\u7b97"},{"location":"math/#_2","text":"\u968f\u673a\u751f\u6210bits\u6bd4\u7279\u5927\u6574\u6570 int bint_rand_bits ( BINT * r , int bits ); \u968f\u673a\u751f\u6210[left, right)\u8303\u56f4\u5927\u6574\u6570 int bint_rand_range ( BINT * r , BINT * left , BINT * right ); \u968f\u673a\u751f\u6210 bits \u6bd4\u7279\u5927\u7d20\u6570 int bint_prime_bits ( BINT * r , int bits ); \u7d20\u6027\u5224\u65ad(\u65e0\u89c6\u7b26\u53f7\u4f4d) int bint_is_prime ( BINT * n , int * status ); Example BINT p ; int status = 0 ; bint_prime_bits ( & p , 256 ); // 256 \u6bd4\u7279\u7d20\u6570 bint_is_prime ( & p , & status ); // \u7d20\u6027\u68c0\u6d4b // is prime if ( status == 1 ) { puts ( \"is prime\" ); } else { puts ( \"not prime\" ); } \u6700\u5927\u516c\u7ea6\u6570 int bint_gcd ( BINT * gcd , BINT * n1 , BINT * n2 );","title":"\u4e00\u3001\u4e00\u822c\u51fd\u6570"},{"location":"math/#_3","text":"Note \u6709\u9650\u57df fp \u8fd0\u7b97\u8981\u6c42\u8f93\u5165\u7684 p \u4e3a\u7d20\u6570\uff0c\u4e14\u8f93\u51fa\u7ed3\u679c\u4e3a\u975e\u8d1f \u6709\u9650\u57df\u52a0\u6cd5 int fp_add ( BINT * r , BINT * n1 , BINT * n2 , BINT * p ); \u6709\u9650\u57df\u51cf\u6cd5 int fp_sub ( BINT * r , BINT * n1 , BINT * n2 , BINT * p ); \u6709\u9650\u57df\u4e58\u6cd5 int fp_mul ( BINT * r , BINT * n1 , BINT * n2 , BINT * p ); \u6709\u9650\u57df\u4e58\u6cd5 int fp_mul_u32 ( BINT * r , BINT * n1 , uint32_t n2 , BINT * p ); \u6709\u9650\u57df\u5e73\u65b9 int fp_sqr ( BINT * r , BINT * n , BINT * p ); \u6709\u9650\u57df\u6c42\u5e42 int fp_pow ( BINT * r , BINT * n , BINT * e , BINT * p ); \u6709\u9650\u57df\u6c42\u9006 int fp_inverse ( BINT * r , BINT * n , BINT * p ); \u6709\u9650\u57df\u53d6\u8d1f int fp_neg ( BINT * r , BINT * n , BINT * p );","title":"\u4e8c\u3001\u6709\u9650\u57df\u8fd0\u7b97"},{"location":"publickey/","text":"\u516c\u94a5\u5bc6\u7801 Warning \u4e3a\u4e86\u7b80\u4fbf\uff0c\u793a\u4f8b\u4ee3\u7801\u4e2d\u5e76\u672a\u8fdb\u884c\u9519\u8bef\u5904\u7406\uff0c \u5b9e\u9645\u60c5\u51b5\u4e0b\u5e94\u5f53\u68c0\u67e5\u51fd\u6570\u8fd4\u56de\u503c\uff0c\u9632\u6b62\u53d1\u751f\u5f02\u5e38 \u4e00\u3001\u7c7b\u578b\u5b9a\u4e49 \u4e8c\u3001\u516c\u94a5\u7b97\u6cd5 2.1 SM2 file: gmlib/publickey/sm2.h \u53c2\u8003\u8d44\u6599 GM/T 0003.1-2012 SM2 \u692d\u5706\u66f2\u7ebf\u516c\u94a5\u5bc6\u7801\u7b97\u6cd5\u7b2c1\u90e8\u5206\uff1a\u603b\u5219 GM/T 0003.2-2012 SM2 \u692d\u5706\u66f2\u7ebf\u516c\u94a5\u5bc6\u7801\u7b97\u6cd5\u7b2c2\u90e8\u5206\uff1a\u6570\u5b57\u7b7e\u540d\u7b97\u6cd5 GM/T 0003.3-2012 SM2 \u692d\u5706\u66f2\u7ebf\u516c\u94a5\u5bc6\u7801\u7b97\u6cd5\u7b2c3\u90e8\u5206\uff1a\u5bc6\u94a5\u4ea4\u6362\u534f\u8bae GM/T 0003.4-2012 SM2 \u692d\u5706\u66f2\u7ebf\u516c\u94a5\u5bc6\u7801\u7b97\u6cd5\u7b2c4\u90e8\u5206\uff1a\u516c\u94a5\u52a0\u5bc6\u7b97\u6cd5 GM/T 0003.5-2012 SM2 \u692d\u5706\u66f2\u7ebf\u516c\u94a5\u5bc6\u7801\u7b97\u6cd5\u7b2c5\u90e8\u5206\uff1a\u53c2\u6570\u5b9a\u4e49 SM2\u6807\u51c6\u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587(Context) extern EC_CTX SM2_Fp256_CTX ; // SM2 \u692d\u5706\u66f2\u7ebf\u53c2\u6570 2.1.1 \u7b7e\u540d\u4e0e\u9a8c\u7b7e Warning \u5728\u7b7e\u540d\u548c\u9a8c\u7b7e\u4e0a\u4e0b\u6587 SM2_SIGN_CTX \uff0c SM2_VERIFY_CTX \u521d\u59cb\u5316\u65f6\u4f20\u5165\u7684\u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587 EC_CTX \u5728\u6574\u4e2a\u7b7e\u540d\u548c\u9a8c\u7b7e\u8fc7\u7a0b\u4e2d\u4e0d\u80fd\u88ab\u91ca\u653e\u6216\u662f\u4fee\u6539\uff0c\u5426\u5219\u5c06\u4f1a\u5bfc\u81f4\u8fd0\u884c\u9519\u8bef \u7b7e\u540d\u4e0a\u4e0b\u6587(Context) typedef struct SM2_SIGN_CTX { // Z = H(ENTL || ID || a || b || G.x || G.y || P.x || P.y) uint8_t Z [ SM3_DIGEST_SIZE ]; // \u7b7e\u540d\u8005\u6807\u8bc6 EC_CTX * ec_ctx ; // \u692d\u5706\u66f2\u7ebf Context SM3_CTX sm3_ctx ; // sm3 Context BINT da ; // \u7b7e\u540d\u8005\u79c1\u94a5 BINT da_plus_1_iv ; // (da+1)^-1 % EC.n } SM2_SIGN_CTX ; \u7b7e\u540d\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316 int sm2_sign_init ( uint8_t ENTL [ 2 ], ///< [in] ID\u6bd4\u5b57\u8282\u957f\u5ea6 uint8_t * ID , ///< [in] \u7b7e\u540d\u8005ID EC_CTX * ec_ctx , ///< [in] \u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587 BINT * da , ///< [in] \u7b7e\u540d\u8005\u79c1\u94a5 ECPoint * P , ///< [in] \u7b7e\u540d\u8005\u516c\u94a5 SM2_SIGN_CTX * sm2_sign_ctx ); \u7b7e\u540d\u4e0a\u4e0b\u6587(Context)\u91cd\u7f6e void sm2_sign_reset ( SM2_SIGN_CTX * sm2_sign_ctx ); \u7b7e\u540d void sm2_sign_update ( uint8_t * in , int inl , SM2_SIGN_CTX * sm2_sign_ctx ); int sm2_sign_final ( uint8_t * out , int * outl , SM2_SIGN_CTX * sm2_sign_ctx ); \u9a8c\u7b7e\u4e0a\u4e0b\u6587 typedef struct SM2_VERIFY_CTX { // Z = H(ENTL || ID || a || b || G.x || G.y || P.x || P.y) uint8_t Z [ SM3_DIGEST_SIZE ]; // \u7b7e\u540d\u8005\u6807\u8bc6 EC_CTX * ec_ctx ; // \u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587 SM3_CTX sm3_ctx ; // SM3\u7b97\u6cd5\u4e0a\u4e0b\u6587 ECPoint P ; // \u7b7e\u540d\u8005\u516c\u94a5 } SM2_VERIFY_CTX ; \u9a8c\u7b7e\u521d\u59cb\u5316 int sm2_verify_init ( uint8_t ENTL [ 2 ], ///< [in] ID\u6bd4\u5b57\u8282\u957f\u5ea6 uint8_t * ID , ///< [in] \u7b7e\u540d\u8005ID EC_CTX * ec_ctx , ///< [in] \u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587 ECPoint * P , ///< [in] \u7b7e\u540d\u8005\u516c\u94a5 SM2_VERIFY_CTX * sm2_verify_ctx ); \u9a8c\u7b7e\u91cd\u7f6e void sm2_verify_reset ( SM2_VERIFY_CTX * sm2_verify_ctx ); \u9a8c\u7b7e void sm2_verify_update ( uint8_t * in , int inl , SM2_VERIFY_CTX * sm2_verify_ctx ); int sm2_verify_final ( int * status , ///< [out] 1(\u6210\u529f),0(\u5931\u8d25) uint8_t * signature , ///< [in] \u7b7e\u540d SM2_VERIFY_CTX * sm2_verify_ctx ); Example #include <gmlib/publickey/sm2.h> #include <gmlib/utils.h> #include <stdio.h> static uint8_t ID_A [] = { 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , // 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , // }; static uint8_t ENTL_A [] = { 0x00 , 0x80 }; // \u7b7e\u540d\u65b9\u79c1\u94a5 static char * da_hex = \"3945208F_7B2144B1_3F36E38A_C6D39F95_88939369_2860B51A_42FB81EF_4DF7C5B8\" ; // \u5f85\u7b7e\u540d\u6d88\u606f static uint8_t msg [] = { 'm' , 'e' , 's' , 's' , 'a' , 'g' , 'e' , ' ' , 'd' , 'i' , 'g' , 'e' , 's' , 't' , }; // signature=(r,s) static uint8_t signature [ 2 * ( GMLIB_BINT_BITS / 8 )]; static int outl ; int main () { BINT da ; // \u79c1\u94a5 ECPoint P ; // \u516c\u94a5 // \u8f7d\u5165\u79c1\u94a5 bint_from_str ( & da , da_hex , 16 ); // \u8ba1\u7b97\u516c\u94a5 P = [da]G ec_mul ( & P , & da , & SM2_Fp256_CTX . G , & SM2_Fp256_CTX ); puts ( \"msg:\" ); dump_data ( msg , sizeof ( msg )); // sm2 \u7b7e\u540d SM2_SIGN_CTX sm2_sign_ctx ; sm2_sign_init ( ENTL_A , ID_A , & SM2_Fp256_CTX , & da , & P , & sm2_sign_ctx ); sm2_sign_update ( msg , sizeof ( msg ), & sm2_sign_ctx ); sm2_sign_final ( signature , & outl , & sm2_sign_ctx ); puts ( \"signature:\" ); dump_data ( signature , outl ); // sm2 \u9a8c\u7b7e SM2_VERIFY_CTX sm2_verify_ctx ; int status = 0 ; // \u7b7e\u540d\u6b63\u786e\u6027 sm2_verify_init ( ENTL_A , ID_A , & SM2_Fp256_CTX , & P , & sm2_verify_ctx ); sm2_verify_update ( msg , sizeof ( msg ), & sm2_verify_ctx ); sm2_verify_final ( & status , signature , & sm2_verify_ctx ); if ( status != 1 ) { puts ( \"check fail!\" ); return -1 ; } puts ( \"check ok!\" ); return 0 ; } 2.1.2 \u52a0\u89e3\u5bc6 \u52a0\u5bc6 int sm2_encrypt ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 int PC , ///< [in] \u692d\u5706\u66f2\u7ebf\u70b9\u8868\u793a\u65b9\u6cd5 EC_CTX * ec_ctx , ///< [in] \u692d\u5706\u66f2\u7ebf\u53c2\u6570 ECPoint * P ///< [in] \u63a5\u6536\u65b9\u516c\u94a5 ); \u89e3\u5bc6 int sm2_decrypt ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 EC_CTX * ec_ctx , ///< [in] \u692d\u5706\u66f2\u7ebf\u53c2\u6570 BINT * da ///< [in] \u63a5\u6536\u8005\u79c1\u94a5 ); Example #include <gmlib/err.h> #include <gmlib/publickey/sm2.h> #include <gmlib/utils.h> #include <memory.h> #include <stdlib.h> static char * da_hex = \"3945208F_7B2144B1_3F36E38A_C6D39F95_88939369_2860B51A_42FB81EF_4DF7C5B8\" ; // \"encryption standard\" static uint8_t msg [] = { 'e' , 'n' , 'c' , 'r' , 'y' , 'p' , 't' , 'i' , 'o' , 'n' , ' ' , 's' , 't' , 'a' , 'n' , 'd' , 'a' , 'r' , 'd' }; static uint8_t out [ 2048 ]; // \u8f93\u51fa static int outl ; // \u8f93\u51fa\u957f\u5ea6 static int PC = EC_PC_NO_ZIP ; // \u975e\u538b\u7f29\u8868\u793a static BINT da ; // \u79c1\u94a5 static ECPoint P ; // \u516c\u94a5 int main () { // \u521d\u59cb\u5316\u53cc\u65b9\u6570\u636e try_goto ( bint_from_str ( & da , da_hex , 16 )); // load da // P = [da]G try_goto ( ec_mul ( & P , & da , & SM2_Fp256_CTX . G , & SM2_Fp256_CTX )); puts ( \"msg:\" ); dump_data ( msg , sizeof ( msg )); // \u52a0\u5bc6 try_goto ( sm2_encrypt ( out , & outl , msg , sizeof ( msg ), PC , & SM2_Fp256_CTX , & P )); puts ( \"ciphertext:\" ); dump_data ( out , outl ); // \u89e3\u5bc6 try_goto ( sm2_decrypt ( out , & outl , out , outl , & SM2_Fp256_CTX , & da )); puts ( \"msg(decrypt):\" ); dump_data ( out , outl ); return 0 ; error : return -1 ; }","title":"\u516c\u94a5\u5bc6\u7801"},{"location":"publickey/#_1","text":"Warning \u4e3a\u4e86\u7b80\u4fbf\uff0c\u793a\u4f8b\u4ee3\u7801\u4e2d\u5e76\u672a\u8fdb\u884c\u9519\u8bef\u5904\u7406\uff0c \u5b9e\u9645\u60c5\u51b5\u4e0b\u5e94\u5f53\u68c0\u67e5\u51fd\u6570\u8fd4\u56de\u503c\uff0c\u9632\u6b62\u53d1\u751f\u5f02\u5e38","title":"\u516c\u94a5\u5bc6\u7801"},{"location":"publickey/#_2","text":"","title":"\u4e00\u3001\u7c7b\u578b\u5b9a\u4e49"},{"location":"publickey/#_3","text":"","title":"\u4e8c\u3001\u516c\u94a5\u7b97\u6cd5"},{"location":"publickey/#21-sm2","text":"file: gmlib/publickey/sm2.h \u53c2\u8003\u8d44\u6599 GM/T 0003.1-2012 SM2 \u692d\u5706\u66f2\u7ebf\u516c\u94a5\u5bc6\u7801\u7b97\u6cd5\u7b2c1\u90e8\u5206\uff1a\u603b\u5219 GM/T 0003.2-2012 SM2 \u692d\u5706\u66f2\u7ebf\u516c\u94a5\u5bc6\u7801\u7b97\u6cd5\u7b2c2\u90e8\u5206\uff1a\u6570\u5b57\u7b7e\u540d\u7b97\u6cd5 GM/T 0003.3-2012 SM2 \u692d\u5706\u66f2\u7ebf\u516c\u94a5\u5bc6\u7801\u7b97\u6cd5\u7b2c3\u90e8\u5206\uff1a\u5bc6\u94a5\u4ea4\u6362\u534f\u8bae GM/T 0003.4-2012 SM2 \u692d\u5706\u66f2\u7ebf\u516c\u94a5\u5bc6\u7801\u7b97\u6cd5\u7b2c4\u90e8\u5206\uff1a\u516c\u94a5\u52a0\u5bc6\u7b97\u6cd5 GM/T 0003.5-2012 SM2 \u692d\u5706\u66f2\u7ebf\u516c\u94a5\u5bc6\u7801\u7b97\u6cd5\u7b2c5\u90e8\u5206\uff1a\u53c2\u6570\u5b9a\u4e49 SM2\u6807\u51c6\u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587(Context) extern EC_CTX SM2_Fp256_CTX ; // SM2 \u692d\u5706\u66f2\u7ebf\u53c2\u6570","title":"2.1 SM2"},{"location":"publickey/#211","text":"Warning \u5728\u7b7e\u540d\u548c\u9a8c\u7b7e\u4e0a\u4e0b\u6587 SM2_SIGN_CTX \uff0c SM2_VERIFY_CTX \u521d\u59cb\u5316\u65f6\u4f20\u5165\u7684\u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587 EC_CTX \u5728\u6574\u4e2a\u7b7e\u540d\u548c\u9a8c\u7b7e\u8fc7\u7a0b\u4e2d\u4e0d\u80fd\u88ab\u91ca\u653e\u6216\u662f\u4fee\u6539\uff0c\u5426\u5219\u5c06\u4f1a\u5bfc\u81f4\u8fd0\u884c\u9519\u8bef \u7b7e\u540d\u4e0a\u4e0b\u6587(Context) typedef struct SM2_SIGN_CTX { // Z = H(ENTL || ID || a || b || G.x || G.y || P.x || P.y) uint8_t Z [ SM3_DIGEST_SIZE ]; // \u7b7e\u540d\u8005\u6807\u8bc6 EC_CTX * ec_ctx ; // \u692d\u5706\u66f2\u7ebf Context SM3_CTX sm3_ctx ; // sm3 Context BINT da ; // \u7b7e\u540d\u8005\u79c1\u94a5 BINT da_plus_1_iv ; // (da+1)^-1 % EC.n } SM2_SIGN_CTX ; \u7b7e\u540d\u4e0a\u4e0b\u6587(Context)\u521d\u59cb\u5316 int sm2_sign_init ( uint8_t ENTL [ 2 ], ///< [in] ID\u6bd4\u5b57\u8282\u957f\u5ea6 uint8_t * ID , ///< [in] \u7b7e\u540d\u8005ID EC_CTX * ec_ctx , ///< [in] \u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587 BINT * da , ///< [in] \u7b7e\u540d\u8005\u79c1\u94a5 ECPoint * P , ///< [in] \u7b7e\u540d\u8005\u516c\u94a5 SM2_SIGN_CTX * sm2_sign_ctx ); \u7b7e\u540d\u4e0a\u4e0b\u6587(Context)\u91cd\u7f6e void sm2_sign_reset ( SM2_SIGN_CTX * sm2_sign_ctx ); \u7b7e\u540d void sm2_sign_update ( uint8_t * in , int inl , SM2_SIGN_CTX * sm2_sign_ctx ); int sm2_sign_final ( uint8_t * out , int * outl , SM2_SIGN_CTX * sm2_sign_ctx ); \u9a8c\u7b7e\u4e0a\u4e0b\u6587 typedef struct SM2_VERIFY_CTX { // Z = H(ENTL || ID || a || b || G.x || G.y || P.x || P.y) uint8_t Z [ SM3_DIGEST_SIZE ]; // \u7b7e\u540d\u8005\u6807\u8bc6 EC_CTX * ec_ctx ; // \u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587 SM3_CTX sm3_ctx ; // SM3\u7b97\u6cd5\u4e0a\u4e0b\u6587 ECPoint P ; // \u7b7e\u540d\u8005\u516c\u94a5 } SM2_VERIFY_CTX ; \u9a8c\u7b7e\u521d\u59cb\u5316 int sm2_verify_init ( uint8_t ENTL [ 2 ], ///< [in] ID\u6bd4\u5b57\u8282\u957f\u5ea6 uint8_t * ID , ///< [in] \u7b7e\u540d\u8005ID EC_CTX * ec_ctx , ///< [in] \u692d\u5706\u66f2\u7ebf\u4e0a\u4e0b\u6587 ECPoint * P , ///< [in] \u7b7e\u540d\u8005\u516c\u94a5 SM2_VERIFY_CTX * sm2_verify_ctx ); \u9a8c\u7b7e\u91cd\u7f6e void sm2_verify_reset ( SM2_VERIFY_CTX * sm2_verify_ctx ); \u9a8c\u7b7e void sm2_verify_update ( uint8_t * in , int inl , SM2_VERIFY_CTX * sm2_verify_ctx ); int sm2_verify_final ( int * status , ///< [out] 1(\u6210\u529f),0(\u5931\u8d25) uint8_t * signature , ///< [in] \u7b7e\u540d SM2_VERIFY_CTX * sm2_verify_ctx ); Example #include <gmlib/publickey/sm2.h> #include <gmlib/utils.h> #include <stdio.h> static uint8_t ID_A [] = { 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , // 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , // }; static uint8_t ENTL_A [] = { 0x00 , 0x80 }; // \u7b7e\u540d\u65b9\u79c1\u94a5 static char * da_hex = \"3945208F_7B2144B1_3F36E38A_C6D39F95_88939369_2860B51A_42FB81EF_4DF7C5B8\" ; // \u5f85\u7b7e\u540d\u6d88\u606f static uint8_t msg [] = { 'm' , 'e' , 's' , 's' , 'a' , 'g' , 'e' , ' ' , 'd' , 'i' , 'g' , 'e' , 's' , 't' , }; // signature=(r,s) static uint8_t signature [ 2 * ( GMLIB_BINT_BITS / 8 )]; static int outl ; int main () { BINT da ; // \u79c1\u94a5 ECPoint P ; // \u516c\u94a5 // \u8f7d\u5165\u79c1\u94a5 bint_from_str ( & da , da_hex , 16 ); // \u8ba1\u7b97\u516c\u94a5 P = [da]G ec_mul ( & P , & da , & SM2_Fp256_CTX . G , & SM2_Fp256_CTX ); puts ( \"msg:\" ); dump_data ( msg , sizeof ( msg )); // sm2 \u7b7e\u540d SM2_SIGN_CTX sm2_sign_ctx ; sm2_sign_init ( ENTL_A , ID_A , & SM2_Fp256_CTX , & da , & P , & sm2_sign_ctx ); sm2_sign_update ( msg , sizeof ( msg ), & sm2_sign_ctx ); sm2_sign_final ( signature , & outl , & sm2_sign_ctx ); puts ( \"signature:\" ); dump_data ( signature , outl ); // sm2 \u9a8c\u7b7e SM2_VERIFY_CTX sm2_verify_ctx ; int status = 0 ; // \u7b7e\u540d\u6b63\u786e\u6027 sm2_verify_init ( ENTL_A , ID_A , & SM2_Fp256_CTX , & P , & sm2_verify_ctx ); sm2_verify_update ( msg , sizeof ( msg ), & sm2_verify_ctx ); sm2_verify_final ( & status , signature , & sm2_verify_ctx ); if ( status != 1 ) { puts ( \"check fail!\" ); return -1 ; } puts ( \"check ok!\" ); return 0 ; }","title":"2.1.1 \u7b7e\u540d\u4e0e\u9a8c\u7b7e"},{"location":"publickey/#212","text":"\u52a0\u5bc6 int sm2_encrypt ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 int PC , ///< [in] \u692d\u5706\u66f2\u7ebf\u70b9\u8868\u793a\u65b9\u6cd5 EC_CTX * ec_ctx , ///< [in] \u692d\u5706\u66f2\u7ebf\u53c2\u6570 ECPoint * P ///< [in] \u63a5\u6536\u65b9\u516c\u94a5 ); \u89e3\u5bc6 int sm2_decrypt ( uint8_t * out , ///< [out] \u8f93\u51fa int * outl , ///< [out] \u8f93\u51fa\u957f\u5ea6 uint8_t * in , ///< [in] \u8f93\u5165 int inl , ///< [in] \u8f93\u5165\u957f\u5ea6 EC_CTX * ec_ctx , ///< [in] \u692d\u5706\u66f2\u7ebf\u53c2\u6570 BINT * da ///< [in] \u63a5\u6536\u8005\u79c1\u94a5 ); Example #include <gmlib/err.h> #include <gmlib/publickey/sm2.h> #include <gmlib/utils.h> #include <memory.h> #include <stdlib.h> static char * da_hex = \"3945208F_7B2144B1_3F36E38A_C6D39F95_88939369_2860B51A_42FB81EF_4DF7C5B8\" ; // \"encryption standard\" static uint8_t msg [] = { 'e' , 'n' , 'c' , 'r' , 'y' , 'p' , 't' , 'i' , 'o' , 'n' , ' ' , 's' , 't' , 'a' , 'n' , 'd' , 'a' , 'r' , 'd' }; static uint8_t out [ 2048 ]; // \u8f93\u51fa static int outl ; // \u8f93\u51fa\u957f\u5ea6 static int PC = EC_PC_NO_ZIP ; // \u975e\u538b\u7f29\u8868\u793a static BINT da ; // \u79c1\u94a5 static ECPoint P ; // \u516c\u94a5 int main () { // \u521d\u59cb\u5316\u53cc\u65b9\u6570\u636e try_goto ( bint_from_str ( & da , da_hex , 16 )); // load da // P = [da]G try_goto ( ec_mul ( & P , & da , & SM2_Fp256_CTX . G , & SM2_Fp256_CTX )); puts ( \"msg:\" ); dump_data ( msg , sizeof ( msg )); // \u52a0\u5bc6 try_goto ( sm2_encrypt ( out , & outl , msg , sizeof ( msg ), PC , & SM2_Fp256_CTX , & P )); puts ( \"ciphertext:\" ); dump_data ( out , outl ); // \u89e3\u5bc6 try_goto ( sm2_decrypt ( out , & outl , out , outl , & SM2_Fp256_CTX , & da )); puts ( \"msg(decrypt):\" ); dump_data ( out , outl ); return 0 ; error : return -1 ; }","title":"2.1.2 \u52a0\u89e3\u5bc6"},{"location":"stream/","text":"\u6d41\u5bc6\u7801 \u4e00\u3001\u7c7b\u578b\u5b9a\u4e49 \u4e8c\u3001\u6d41\u5bc6\u7801\u7b97\u6cd5 2.1 ZUC \u7956\u51b2\u4e4b\u7b97\u6cd5 file: gmlib/stream/zuc.h ZUC\u7b97\u6cd5\u4e0a\u4e0b\u6587(Context) // \u7956\u51b2\u4e4b\u7b97\u6cd5\u5bc6\u94a5\u957f\u5ea6 #define ZUC_KEYLEN 16 // \u7956\u51b2\u4e4b\u7b97\u6cd5\u521d\u59cb\u5411\u91cf\u957f\u5ea6 #define ZUC_IVLEN 16 typedef struct ZUC_CTX { uint32_t lsfr [ 16 ]; // 16\u4e2a31\u6bd4\u7279\u5bc4\u5b58\u5668 uint32_t r1 , r2 ; } ZUC_CTX ; \u4e0a\u4e0b\u6587\u521d\u59cb\u5316 void zuc_init ( uint8_t * key , uint8_t * iv , ZUC_CTX * zuc_ctx ); \u751f\u6210\u4e0b\u4e00\u8282\u62cd32\u6bd4\u7279\u5bc6\u94a5 uint32_t zuc_next ( ZUC_CTX * zuc_ctx ); void zuc_put_next ( uint8_t * out , ZUC_CTX * zuc_ctx ); Example #include <gmlib/stream/zuc.h> #include <stdio.h> static uint8_t key [ ZUC_KEYLEN ] = { 0 }; static uint8_t iv [ ZUC_IVLEN ] = { 0 }; int main () { ZUC_CTX ctx ; uint32_t Z ; // test 1 zuc_init ( key , iv , & ctx ); Z = zuc_next ( & ctx ); printf ( \"%08x, \" , Z ); // 27bede74 Z = zuc_next ( & ctx ); printf ( \"%08x, \" , Z ); // 018082da return 0 ; } 2.1.1 ZUC \u673a\u5bc6\u6027\u7b97\u6cd5 \u673a\u5bc6\u6027\u7b97\u6cd5\u52a0/\u89e3\u5bc6 void zuc_confidentiality_crypt ( uint8_t * out , ///< [out] \u8f93\u51fa uint8_t * in , ///< [in] \u8f93\u5165 int inbits , ///< [in] \u8f93\u5165\u6bd4\u7279\u957f\u5ea6 uint32_t COUNT , ///< [in] \u8ba1\u6570\u5668 uint8_t BEARER , ///< [in] \u627f\u8f7d\u5c42\u6807\u8bc6(5\u6bd4\u7279) uint8_t DIRECTION , ///< [in] \u4f20\u64ad\u65b9\u5411\u6807\u8bc6(1\u6bd4\u7279) uint8_t * CK ///< [in] 128\u6bd4\u7279\u673a\u5bc6\u6027\u5bc6\u94a5 ); 2.1.2 ZUC \u5b8c\u6574\u6027\u7b97\u6cd5 #define ZUC_MAC_SIZE 4 void zuc_integrity_mac ( uint8_t * out , ///< [out] \u8f93\u51fa uint8_t * in , ///< [in] \u8f93\u5165 int inbits , ///< [in] \u8f93\u5165\u6bd4\u7279\u957f\u5ea6 uint32_t COUNT , ///< [in] \u8ba1\u6570\u5668 uint8_t BEARER , ///< [in] \u627f\u8f7d\u5c42\u6807\u8bc6(5\u6bd4\u7279) uint8_t DIRECTION , ///< [in] \u4f20\u64ad\u65b9\u5411\u6807\u8bc6(1\u6bd4\u7279) uint8_t * IK ///< [in] 128\u6bd4\u7279\u5b8c\u6574\u6027\u5bc6\u94a5 );","title":"\u6d41\u5bc6\u7801"},{"location":"stream/#_1","text":"","title":"\u6d41\u5bc6\u7801"},{"location":"stream/#_2","text":"","title":"\u4e00\u3001\u7c7b\u578b\u5b9a\u4e49"},{"location":"stream/#_3","text":"","title":"\u4e8c\u3001\u6d41\u5bc6\u7801\u7b97\u6cd5"},{"location":"stream/#21-zuc","text":"file: gmlib/stream/zuc.h ZUC\u7b97\u6cd5\u4e0a\u4e0b\u6587(Context) // \u7956\u51b2\u4e4b\u7b97\u6cd5\u5bc6\u94a5\u957f\u5ea6 #define ZUC_KEYLEN 16 // \u7956\u51b2\u4e4b\u7b97\u6cd5\u521d\u59cb\u5411\u91cf\u957f\u5ea6 #define ZUC_IVLEN 16 typedef struct ZUC_CTX { uint32_t lsfr [ 16 ]; // 16\u4e2a31\u6bd4\u7279\u5bc4\u5b58\u5668 uint32_t r1 , r2 ; } ZUC_CTX ; \u4e0a\u4e0b\u6587\u521d\u59cb\u5316 void zuc_init ( uint8_t * key , uint8_t * iv , ZUC_CTX * zuc_ctx ); \u751f\u6210\u4e0b\u4e00\u8282\u62cd32\u6bd4\u7279\u5bc6\u94a5 uint32_t zuc_next ( ZUC_CTX * zuc_ctx ); void zuc_put_next ( uint8_t * out , ZUC_CTX * zuc_ctx ); Example #include <gmlib/stream/zuc.h> #include <stdio.h> static uint8_t key [ ZUC_KEYLEN ] = { 0 }; static uint8_t iv [ ZUC_IVLEN ] = { 0 }; int main () { ZUC_CTX ctx ; uint32_t Z ; // test 1 zuc_init ( key , iv , & ctx ); Z = zuc_next ( & ctx ); printf ( \"%08x, \" , Z ); // 27bede74 Z = zuc_next ( & ctx ); printf ( \"%08x, \" , Z ); // 018082da return 0 ; }","title":"2.1 ZUC \u7956\u51b2\u4e4b\u7b97\u6cd5"},{"location":"stream/#211-zuc","text":"\u673a\u5bc6\u6027\u7b97\u6cd5\u52a0/\u89e3\u5bc6 void zuc_confidentiality_crypt ( uint8_t * out , ///< [out] \u8f93\u51fa uint8_t * in , ///< [in] \u8f93\u5165 int inbits , ///< [in] \u8f93\u5165\u6bd4\u7279\u957f\u5ea6 uint32_t COUNT , ///< [in] \u8ba1\u6570\u5668 uint8_t BEARER , ///< [in] \u627f\u8f7d\u5c42\u6807\u8bc6(5\u6bd4\u7279) uint8_t DIRECTION , ///< [in] \u4f20\u64ad\u65b9\u5411\u6807\u8bc6(1\u6bd4\u7279) uint8_t * CK ///< [in] 128\u6bd4\u7279\u673a\u5bc6\u6027\u5bc6\u94a5 );","title":"2.1.1 ZUC \u673a\u5bc6\u6027\u7b97\u6cd5"},{"location":"stream/#212-zuc","text":"#define ZUC_MAC_SIZE 4 void zuc_integrity_mac ( uint8_t * out , ///< [out] \u8f93\u51fa uint8_t * in , ///< [in] \u8f93\u5165 int inbits , ///< [in] \u8f93\u5165\u6bd4\u7279\u957f\u5ea6 uint32_t COUNT , ///< [in] \u8ba1\u6570\u5668 uint8_t BEARER , ///< [in] \u627f\u8f7d\u5c42\u6807\u8bc6(5\u6bd4\u7279) uint8_t DIRECTION , ///< [in] \u4f20\u64ad\u65b9\u5411\u6807\u8bc6(1\u6bd4\u7279) uint8_t * IK ///< [in] 128\u6bd4\u7279\u5b8c\u6574\u6027\u5bc6\u94a5 );","title":"2.1.2 ZUC \u5b8c\u6574\u6027\u7b97\u6cd5"},{"location":"utils/","text":"\u529f\u80fd\u51fd\u6570 file: gmlib/utils.h \u4e00\u3001\u6570\u636e\u8bfb\u5199 1.1 \u5927\u7aef\u6570\u636e\u8bfb\u53d6 \u4ee5\u5927\u7aef\u5f62\u5f0f\u8bfb\u53d632\u6bd4\u7279\u6570 uint32_t loadu32_be ( uint8_t * src ); \u4ee5\u5927\u7aef\u5f62\u5f0f\u8bfb\u53d664\u6bd4\u7279\u6570 uint64_t loadu64_be ( uint8_t * src ); 1.2 \u5927\u7aef\u6570\u636e\u5b58\u50a8 \u4ee5\u5927\u7aef\u5f62\u5f0f\u5b58\u50a832\u6bd4\u7279\u6570 void storeu32_be ( uint8_t * dst , uint32_t n ); \u4ee5\u5927\u7aef\u5f62\u5f0f\u5b58\u50a864\u6bd4\u7279\u6570 void storeu64_be ( uint8_t * dst , uint64_t n ); \u4e8c\u3001\u6570\u636elog \u6253\u5370\u5185\u5b58\u6570\u636e void dump_data ( uint8_t * d , int len ); \u4e09\u3001\u5185\u5b58\u64cd\u4f5c \u5b57\u8282\u5f02\u6216 void memxor ( uint8_t * dst , uint8_t * a , uint8_t * b , int size ); \u5185\u5b58\u968f\u673a\u5316 void rand_mem ( uint8_t * mem , int size );","title":"\u529f\u80fd\u51fd\u6570"},{"location":"utils/#_1","text":"file: gmlib/utils.h","title":"\u529f\u80fd\u51fd\u6570"},{"location":"utils/#_2","text":"","title":"\u4e00\u3001\u6570\u636e\u8bfb\u5199"},{"location":"utils/#11","text":"\u4ee5\u5927\u7aef\u5f62\u5f0f\u8bfb\u53d632\u6bd4\u7279\u6570 uint32_t loadu32_be ( uint8_t * src ); \u4ee5\u5927\u7aef\u5f62\u5f0f\u8bfb\u53d664\u6bd4\u7279\u6570 uint64_t loadu64_be ( uint8_t * src );","title":"1.1 \u5927\u7aef\u6570\u636e\u8bfb\u53d6"},{"location":"utils/#12","text":"\u4ee5\u5927\u7aef\u5f62\u5f0f\u5b58\u50a832\u6bd4\u7279\u6570 void storeu32_be ( uint8_t * dst , uint32_t n ); \u4ee5\u5927\u7aef\u5f62\u5f0f\u5b58\u50a864\u6bd4\u7279\u6570 void storeu64_be ( uint8_t * dst , uint64_t n );","title":"1.2 \u5927\u7aef\u6570\u636e\u5b58\u50a8"},{"location":"utils/#log","text":"\u6253\u5370\u5185\u5b58\u6570\u636e void dump_data ( uint8_t * d , int len );","title":"\u4e8c\u3001\u6570\u636elog"},{"location":"utils/#_3","text":"\u5b57\u8282\u5f02\u6216 void memxor ( uint8_t * dst , uint8_t * a , uint8_t * b , int size ); \u5185\u5b58\u968f\u673a\u5316 void rand_mem ( uint8_t * mem , int size );","title":"\u4e09\u3001\u5185\u5b58\u64cd\u4f5c"}]}